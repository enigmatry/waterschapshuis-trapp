/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IRolesClient {
    /**
     * Gets listing of all existing Roles
     * @param query (optional) 
     * @return List of Roles
     */
    getAllRoles(query: GetRolesQuery | null | undefined): Observable<GetRolesResponse>;
    /**
     * Updates Roles Permissions
     * @return List of Roles With Permissions
     */
    updateRolesPermissions(command: UpdateRolesPermissionsCommand): Observable<GetRolesResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RolesClient implements IRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all existing Roles
     * @param query (optional) 
     * @return List of Roles
     */
    getAllRoles(query: GetRolesQuery | null | undefined): Observable<GetRolesResponse> {
        let url_ = this.baseUrl + "/Roles?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<GetRolesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRolesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<GetRolesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRolesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRolesResponse>(<any>null);
    }

    /**
     * Updates Roles Permissions
     * @return List of Roles With Permissions
     */
    updateRolesPermissions(command: UpdateRolesPermissionsCommand): Observable<GetRolesResponse> {
        let url_ = this.baseUrl + "/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRolesPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRolesPermissions(<any>response_);
                } catch (e) {
                    return <Observable<GetRolesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRolesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRolesPermissions(response: HttpResponseBase): Observable<GetRolesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRolesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRolesResponse>(<any>null);
    }
}

export interface IUsersClient {
    /**
     * Gets listing of all available users
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of users
     */
    search(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetUsersResponseItem>;
    /**
     * Updates user data
     * @param command User data for authorized and organization
     */
    post(command: UserUpdateCommand): Observable<GetUserDetailsResponse>;
    /**
     * Get user details for given id
     * @param id GUID of the user
     */
    get(id: string): Observable<GetUserDetailsResponse>;
    /**
     * Update user roles
     * @param command List of
     */
    put(command: UpdateUserRolesCommand): Observable<GetUserDetailsResponse>;
    /**
     * Creates or updates user confidentiality
     * @param command User data about confidentiality confirmation
     */
    updateConfidentiality(command: UserUpdateConfidentialityCommand): Observable<GetUserDetailsResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available users
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of users
     */
    search(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetUsersResponseItem> {
        let url_ = this.baseUrl + "/Users?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetUsersResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetUsersResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PagedResponseOfGetUsersResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetUsersResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetUsersResponseItem>(<any>null);
    }

    /**
     * Updates user data
     * @param command User data for authorized and organization
     */
    post(command: UserUpdateCommand): Observable<GetUserDetailsResponse> {
        let url_ = this.baseUrl + "/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetUserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDetailsResponse>(<any>null);
    }

    /**
     * Get user details for given id
     * @param id GUID of the user
     */
    get(id: string): Observable<GetUserDetailsResponse> {
        let url_ = this.baseUrl + "/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetUserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDetailsResponse>(<any>null);
    }

    /**
     * Update user roles
     * @param command List of
     */
    put(command: UpdateUserRolesCommand): Observable<GetUserDetailsResponse> {
        let url_ = this.baseUrl + "/Users/user-roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<GetUserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDetailsResponse>(<any>null);
    }

    /**
     * Creates or updates user confidentiality
     * @param command User data about confidentiality confirmation
     */
    updateConfidentiality(command: UserUpdateConfidentialityCommand): Observable<GetUserDetailsResponse> {
        let url_ = this.baseUrl + "/Users/update-confidentiality";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConfidentiality(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfidentiality(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfidentiality(response: HttpResponseBase): Observable<GetUserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDetailsResponse>(<any>null);
    }
}

export interface ITrapTypesClient {
    /**
     * Gets listing of all available Trap types info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of Trap types
     */
    searchTrapType(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTrapTypeResponse>;
    /**
     * Creates or updates trap types
     * @param command Trap type data
     */
    post(command: TrapTypeCreateOrUpdateCommand): Observable<GetTrapTypeResponse>;
    /**
     * Get trap type details for given id
     * @param id Id of the trap type
     */
    getTrapType(id: string): Observable<GetTrapTypeResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TrapTypesClient implements ITrapTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available Trap types info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of Trap types
     */
    searchTrapType(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTrapTypeResponse> {
        let url_ = this.baseUrl + "/TrapTypes?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchTrapType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTrapType(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetTrapTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetTrapTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSearchTrapType(response: HttpResponseBase): Observable<PagedResponseOfGetTrapTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetTrapTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetTrapTypeResponse>(<any>null);
    }

    /**
     * Creates or updates trap types
     * @param command Trap type data
     */
    post(command: TrapTypeCreateOrUpdateCommand): Observable<GetTrapTypeResponse> {
        let url_ = this.baseUrl + "/TrapTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetTrapTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTrapTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapTypeResponse>(<any>null);
    }

    /**
     * Get trap type details for given id
     * @param id Id of the trap type
     */
    getTrapType(id: string): Observable<GetTrapTypeResponse> {
        let url_ = this.baseUrl + "/TrapTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrapType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrapType(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrapType(response: HttpResponseBase): Observable<GetTrapTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTrapTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapTypeResponse>(<any>null);
    }
}

export interface ITrapsClient {
    /**
     * Get trap details for given id
     * @param id GUID of the trap
     */
    get(id: string): Observable<GetTrapDetailsTrapItem>;
    /**
     * Physically delete trap
     * @param id Trap id to be deleted
     */
    delete(id: string): Observable<boolean>;
    /**
     * Get trap details for multiple given trap ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetTrapDetailsTrapItem[]>;
    /**
     * Updates trap
     * @param command Trap data
     */
    put(command: TrapUpdateCommand): Observable<GetTrapDetailsTrapItem>;
}

@Injectable({
    providedIn: 'root'
})
export class TrapsClient implements ITrapsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Get trap details for given id
     * @param id GUID of the trap
     */
    get(id: string): Observable<GetTrapDetailsTrapItem> {
        let url_ = this.baseUrl + "/Traps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetTrapDetailsTrapItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTrapDetailsTrapItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapDetailsTrapItem>(<any>null);
    }

    /**
     * Physically delete trap
     * @param id Trap id to be deleted
     */
    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/Traps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Get trap details for multiple given trap ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetTrapDetailsTrapItem[]> {
        let url_ = this.baseUrl + "/Traps?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultiple(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapDetailsTrapItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapDetailsTrapItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMultiple(response: HttpResponseBase): Observable<GetTrapDetailsTrapItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTrapDetailsTrapItem.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapDetailsTrapItem[]>(<any>null);
    }

    /**
     * Updates trap
     * @param command Trap data
     */
    put(command: TrapUpdateCommand): Observable<GetTrapDetailsTrapItem> {
        let url_ = this.baseUrl + "/Traps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<GetTrapDetailsTrapItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTrapDetailsTrapItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapDetailsTrapItem>(<any>null);
    }
}

export interface ITopologiesClient {
    /**
     * Returns all version regional layouts
     */
    getAllVersionRegionalLayouts(): Observable<ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse>;
    /**
     * Returns job info
     */
    getScheduledJobInfo(): Observable<GetScheduledJobsResponse>;
    /**
     * Returns version regional layout import info, if exists
     */
    getVersionRegionalLayoutImport(): Observable<GetVersionRegionalLayoutImportResponse>;
    /**
     * Export current SubAreas topology configurations in CSV format
     */
    exportTopologies(): Observable<FileResponse>;
    /**
     * Import new SubAreas topology configurations in CSV format
     */
    importTopologies(command: ImportVersionRegionalLayout): Observable<VersionRegionalLayoutCreateResult>;
    calculateKmWaterways(): Observable<GetScheduledJobsResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TopologiesClient implements ITopologiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Returns all version regional layouts
     */
    getAllVersionRegionalLayouts(): Observable<ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse> {
        let url_ = this.baseUrl + "/Topologies/version-regional-layout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVersionRegionalLayouts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVersionRegionalLayouts(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVersionRegionalLayouts(response: HttpResponseBase): Observable<ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse>(<any>null);
    }

    /**
     * Returns job info
     */
    getScheduledJobInfo(): Observable<GetScheduledJobsResponse> {
        let url_ = this.baseUrl + "/Topologies/job-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduledJobInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduledJobInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetScheduledJobsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScheduledJobsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduledJobInfo(response: HttpResponseBase): Observable<GetScheduledJobsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetScheduledJobsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScheduledJobsResponse>(<any>null);
    }

    /**
     * Returns version regional layout import info, if exists
     */
    getVersionRegionalLayoutImport(): Observable<GetVersionRegionalLayoutImportResponse> {
        let url_ = this.baseUrl + "/Topologies/version-regional-layout-import";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVersionRegionalLayoutImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersionRegionalLayoutImport(<any>response_);
                } catch (e) {
                    return <Observable<GetVersionRegionalLayoutImportResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVersionRegionalLayoutImportResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersionRegionalLayoutImport(response: HttpResponseBase): Observable<GetVersionRegionalLayoutImportResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVersionRegionalLayoutImportResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVersionRegionalLayoutImportResponse>(<any>null);
    }

    /**
     * Export current SubAreas topology configurations in CSV format
     */
    exportTopologies(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Topologies/version-regional-layout/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTopologies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTopologies(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExportTopologies(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Import new SubAreas topology configurations in CSV format
     */
    importTopologies(command: ImportVersionRegionalLayout): Observable<VersionRegionalLayoutCreateResult> {
        let url_ = this.baseUrl + "/Topologies/version-regional-layout/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportTopologies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTopologies(<any>response_);
                } catch (e) {
                    return <Observable<VersionRegionalLayoutCreateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VersionRegionalLayoutCreateResult>><any>_observableThrow(response_);
        }));
    }

    protected processImportTopologies(response: HttpResponseBase): Observable<VersionRegionalLayoutCreateResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionRegionalLayoutCreateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VersionRegionalLayoutCreateResult>(<any>null);
    }

    calculateKmWaterways(): Observable<GetScheduledJobsResponse> {
        let url_ = this.baseUrl + "/Topologies/calculate-km-waterways";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateKmWaterways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateKmWaterways(<any>response_);
                } catch (e) {
                    return <Observable<GetScheduledJobsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScheduledJobsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCalculateKmWaterways(response: HttpResponseBase): Observable<GetScheduledJobsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetScheduledJobsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScheduledJobsResponse>(<any>null);
    }
}

export interface ITimeRegistrationsClient {
    /**
     * Get time registrations for the current user for the requested period
     * @param startDate (optional) The start date of the requested time registrations
     * @param endDate (optional) The end date of the requested time registrations
     * @param userId (optional) User id to get time registrations for
     * @param rayonId (optional) Rayon id where user registered time
     */
    getForUser(startDate: Date | undefined, endDate: Date | undefined, userId: string | undefined, rayonId: string | null | undefined): Observable<GetTimeRegistrationsOfWeekResponse>;
    /**
     * Creates, updates or deletes TimeRegistration data
     * @param userId (optional) id of user for whom to edit time registrations
     * @param rayonId (optional) id of rayon where user registered hours
     * @param command TimeRegistration data for update
     */
    postForUser(userId: string | undefined, rayonId: string | null | undefined, command: TimeRegistrationsEditCommand): Observable<GetTimeRegistrationsOfWeekResponse>;
    /**
     * Get time registrations for the current user for the requested period
     * @param startDate (optional) The start date of the requested time registrations
     * @param endDate (optional) The end date of the requested time registrations
     */
    get(startDate: Date | undefined, endDate: Date | undefined): Observable<GetTimeRegistrationsOfWeekResponse>;
    /**
     * Creates, updates or deletes TimeRegistration data
     * @param command TimeRegistration data for update
     */
    post(command: TimeRegistrationsEditCommand): Observable<GetTimeRegistrationsOfWeekResponse>;
    /**
     * Get time registration per rayon
     * @param startDate (optional) The start date of the requested time registrations
     * @param endDate (optional) The end date of the requested time registrations
     */
    getUsersWhoHaveRegisteredTimePerRayon(startDate: Date | undefined, endDate: Date | undefined): Observable<GetTimeRegistrationPerRayonResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TimeRegistrationsClient implements ITimeRegistrationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Get time registrations for the current user for the requested period
     * @param startDate (optional) The start date of the requested time registrations
     * @param endDate (optional) The end date of the requested time registrations
     * @param userId (optional) User id to get time registrations for
     * @param rayonId (optional) Rayon id where user registered time
     */
    getForUser(startDate: Date | undefined, endDate: Date | undefined, userId: string | undefined, rayonId: string | null | undefined): Observable<GetTimeRegistrationsOfWeekResponse> {
        let url_ = this.baseUrl + "/TimeRegistrations/management?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (rayonId !== undefined && rayonId !== null)
            url_ += "rayonId=" + encodeURIComponent("" + rayonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForUser(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetForUser(response: HttpResponseBase): Observable<GetTimeRegistrationsOfWeekResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationsOfWeekResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationsOfWeekResponse>(<any>null);
    }

    /**
     * Creates, updates or deletes TimeRegistration data
     * @param userId (optional) id of user for whom to edit time registrations
     * @param rayonId (optional) id of rayon where user registered hours
     * @param command TimeRegistration data for update
     */
    postForUser(userId: string | undefined, rayonId: string | null | undefined, command: TimeRegistrationsEditCommand): Observable<GetTimeRegistrationsOfWeekResponse> {
        let url_ = this.baseUrl + "/TimeRegistrations/management?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (rayonId !== undefined && rayonId !== null)
            url_ += "rayonId=" + encodeURIComponent("" + rayonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostForUser(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPostForUser(response: HttpResponseBase): Observable<GetTimeRegistrationsOfWeekResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationsOfWeekResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationsOfWeekResponse>(<any>null);
    }

    /**
     * Get time registrations for the current user for the requested period
     * @param startDate (optional) The start date of the requested time registrations
     * @param endDate (optional) The end date of the requested time registrations
     */
    get(startDate: Date | undefined, endDate: Date | undefined): Observable<GetTimeRegistrationsOfWeekResponse> {
        let url_ = this.baseUrl + "/TimeRegistrations?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetTimeRegistrationsOfWeekResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationsOfWeekResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationsOfWeekResponse>(<any>null);
    }

    /**
     * Creates, updates or deletes TimeRegistration data
     * @param command TimeRegistration data for update
     */
    post(command: TimeRegistrationsEditCommand): Observable<GetTimeRegistrationsOfWeekResponse> {
        let url_ = this.baseUrl + "/TimeRegistrations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationsOfWeekResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetTimeRegistrationsOfWeekResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationsOfWeekResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationsOfWeekResponse>(<any>null);
    }

    /**
     * Get time registration per rayon
     * @param startDate (optional) The start date of the requested time registrations
     * @param endDate (optional) The end date of the requested time registrations
     */
    getUsersWhoHaveRegisteredTimePerRayon(startDate: Date | undefined, endDate: Date | undefined): Observable<GetTimeRegistrationPerRayonResponse> {
        let url_ = this.baseUrl + "/TimeRegistrations/users-per-rayon?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersWhoHaveRegisteredTimePerRayon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersWhoHaveRegisteredTimePerRayon(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationPerRayonResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationPerRayonResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersWhoHaveRegisteredTimePerRayon(response: HttpResponseBase): Observable<GetTimeRegistrationPerRayonResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationPerRayonResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationPerRayonResponse>(<any>null);
    }
}

export interface ITimeRegistrationCategoryClient {
    /**
     * Gets listing of all available time registration categories info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of time registration categories
     */
    searchTimeRegistrationCategories(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTimeRegistrationCategoryResponse>;
    /**
     * Creates or updates time registration category
     * @param command time registration category data
     */
    post(command: TimeRegistrationCategoryCreateOrUpdateCommand): Observable<GetTimeRegistrationCategoryResponse>;
    /**
     * Get time registration category details for given id
     * @param id Id of the time registration category
     */
    getTimeRegistrationCategory(id: string): Observable<GetTimeRegistrationCategoryResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TimeRegistrationCategoryClient implements ITimeRegistrationCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available time registration categories info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of time registration categories
     */
    searchTimeRegistrationCategories(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTimeRegistrationCategoryResponse> {
        let url_ = this.baseUrl + "/TimeRegistrationCategory?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchTimeRegistrationCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTimeRegistrationCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetTimeRegistrationCategoryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetTimeRegistrationCategoryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSearchTimeRegistrationCategories(response: HttpResponseBase): Observable<PagedResponseOfGetTimeRegistrationCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetTimeRegistrationCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetTimeRegistrationCategoryResponse>(<any>null);
    }

    /**
     * Creates or updates time registration category
     * @param command time registration category data
     */
    post(command: TimeRegistrationCategoryCreateOrUpdateCommand): Observable<GetTimeRegistrationCategoryResponse> {
        let url_ = this.baseUrl + "/TimeRegistrationCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationCategoryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationCategoryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetTimeRegistrationCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationCategoryResponse>(<any>null);
    }

    /**
     * Get time registration category details for given id
     * @param id Id of the time registration category
     */
    getTimeRegistrationCategory(id: string): Observable<GetTimeRegistrationCategoryResponse> {
        let url_ = this.baseUrl + "/TimeRegistrationCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimeRegistrationCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimeRegistrationCategory(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationCategoryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationCategoryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimeRegistrationCategory(response: HttpResponseBase): Observable<GetTimeRegistrationCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationCategoryResponse>(<any>null);
    }
}

export interface ISettingsClient {
    /**
     * Getting authorization settings for the GeoServer
     * @return Authorization keys for backoffice and mobile user
     */
    getGeoServerSettings(): Observable<GetGeoServerSettingsResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SettingsClient implements ISettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Getting authorization settings for the GeoServer
     * @return Authorization keys for backoffice and mobile user
     */
    getGeoServerSettings(): Observable<GetGeoServerSettingsResponse> {
        let url_ = this.baseUrl + "/Settings/geoserver";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeoServerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeoServerSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetGeoServerSettingsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeoServerSettingsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeoServerSettings(response: HttpResponseBase): Observable<GetGeoServerSettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeoServerSettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeoServerSettingsResponse>(<any>null);
    }
}

export interface IReportsClient {
    /**
     * Gets catches and hours prediction for four seasons
     * @param hourSquareId (optional) 
     * @param summerCatches (optional) 
     * @param springCatches (optional) 
     * @param autumnCatches (optional) 
     * @param winterCatches (optional) 
     * @param summerHours (optional) 
     * @param springHours (optional) 
     * @param autumnHours (optional) 
     * @param winterHours (optional) 
     */
    getPrediction(hourSquareId: string | undefined, summerCatches: number | undefined, springCatches: number | undefined, autumnCatches: number | undefined, winterCatches: number | undefined, summerHours: number | undefined, springHours: number | undefined, autumnHours: number | undefined, winterHours: number | undefined): Observable<GetPredictionResponse>;
    /**
     * Gets all active and not exported report templates
     * @return List of all active and not exported report templates
     */
    getReportTemplates(): Observable<GetReportTemplatesResponse>;
    /**
     * Creates report template for export
     * @param command Origin report template Uri, export report title and fields selection
     * @return Report template for export
     */
    createReportTemplate(command: CreateReportTemplateExportCommand): Observable<CreateReportTemplateExportResult>;
    /**
     * Gets report template by Id
     * @return Active report template
     */
    getReportTemplate(id: string): Observable<GetReportTemplateResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReportsClient implements IReportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets catches and hours prediction for four seasons
     * @param hourSquareId (optional) 
     * @param summerCatches (optional) 
     * @param springCatches (optional) 
     * @param autumnCatches (optional) 
     * @param winterCatches (optional) 
     * @param summerHours (optional) 
     * @param springHours (optional) 
     * @param autumnHours (optional) 
     * @param winterHours (optional) 
     */
    getPrediction(hourSquareId: string | undefined, summerCatches: number | undefined, springCatches: number | undefined, autumnCatches: number | undefined, winterCatches: number | undefined, summerHours: number | undefined, springHours: number | undefined, autumnHours: number | undefined, winterHours: number | undefined): Observable<GetPredictionResponse> {
        let url_ = this.baseUrl + "/Reports/prediction?";
        if (hourSquareId === null)
            throw new Error("The parameter 'hourSquareId' cannot be null.");
        else if (hourSquareId !== undefined)
            url_ += "HourSquareId=" + encodeURIComponent("" + hourSquareId) + "&";
        if (summerCatches === null)
            throw new Error("The parameter 'summerCatches' cannot be null.");
        else if (summerCatches !== undefined)
            url_ += "SummerCatches=" + encodeURIComponent("" + summerCatches) + "&";
        if (springCatches === null)
            throw new Error("The parameter 'springCatches' cannot be null.");
        else if (springCatches !== undefined)
            url_ += "SpringCatches=" + encodeURIComponent("" + springCatches) + "&";
        if (autumnCatches === null)
            throw new Error("The parameter 'autumnCatches' cannot be null.");
        else if (autumnCatches !== undefined)
            url_ += "AutumnCatches=" + encodeURIComponent("" + autumnCatches) + "&";
        if (winterCatches === null)
            throw new Error("The parameter 'winterCatches' cannot be null.");
        else if (winterCatches !== undefined)
            url_ += "WinterCatches=" + encodeURIComponent("" + winterCatches) + "&";
        if (summerHours === null)
            throw new Error("The parameter 'summerHours' cannot be null.");
        else if (summerHours !== undefined)
            url_ += "SummerHours=" + encodeURIComponent("" + summerHours) + "&";
        if (springHours === null)
            throw new Error("The parameter 'springHours' cannot be null.");
        else if (springHours !== undefined)
            url_ += "SpringHours=" + encodeURIComponent("" + springHours) + "&";
        if (autumnHours === null)
            throw new Error("The parameter 'autumnHours' cannot be null.");
        else if (autumnHours !== undefined)
            url_ += "AutumnHours=" + encodeURIComponent("" + autumnHours) + "&";
        if (winterHours === null)
            throw new Error("The parameter 'winterHours' cannot be null.");
        else if (winterHours !== undefined)
            url_ += "WinterHours=" + encodeURIComponent("" + winterHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrediction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrediction(<any>response_);
                } catch (e) {
                    return <Observable<GetPredictionResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPredictionResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrediction(response: HttpResponseBase): Observable<GetPredictionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPredictionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPredictionResponse>(<any>null);
    }

    /**
     * Gets all active and not exported report templates
     * @return List of all active and not exported report templates
     */
    getReportTemplates(): Observable<GetReportTemplatesResponse> {
        let url_ = this.baseUrl + "/Reports/templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplates(<any>response_);
                } catch (e) {
                    return <Observable<GetReportTemplatesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportTemplatesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportTemplates(response: HttpResponseBase): Observable<GetReportTemplatesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportTemplatesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportTemplatesResponse>(<any>null);
    }

    /**
     * Creates report template for export
     * @param command Origin report template Uri, export report title and fields selection
     * @return Report template for export
     */
    createReportTemplate(command: CreateReportTemplateExportCommand): Observable<CreateReportTemplateExportResult> {
        let url_ = this.baseUrl + "/Reports/templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReportTemplate(<any>response_);
                } catch (e) {
                    return <Observable<CreateReportTemplateExportResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateReportTemplateExportResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReportTemplate(response: HttpResponseBase): Observable<CreateReportTemplateExportResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateReportTemplateExportResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateReportTemplateExportResult>(<any>null);
    }

    /**
     * Gets report template by Id
     * @return Active report template
     */
    getReportTemplate(id: string): Observable<GetReportTemplateResponse> {
        let url_ = this.baseUrl + "/Reports/templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplate(<any>response_);
                } catch (e) {
                    return <Observable<GetReportTemplateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportTemplateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportTemplate(response: HttpResponseBase): Observable<GetReportTemplateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportTemplateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportTemplateResponse>(<any>null);
    }
}

export interface IOrganizationsClient {
    /**
     * Gets listing of all available Organizations
     * @param query (optional) 
     * @return List of organizations
     */
    search(query: GetOrganizationsQuery | null | undefined): Observable<GetOrganizationsResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationsClient implements IOrganizationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available Organizations
     * @param query (optional) 
     * @return List of organizations
     */
    search(query: GetOrganizationsQuery | null | undefined): Observable<GetOrganizationsResponse> {
        let url_ = this.baseUrl + "/Organizations?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<GetOrganizationsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOrganizationsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<GetOrganizationsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOrganizationsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOrganizationsResponse>(<any>null);
    }
}

export interface IObservationsClient {
    /**
     * Get observations for given observation ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetObservationDetailsResponseItem[]>;
    /**
     * Updates an observation
     * @param command A command for archiving observation or updating remarks
     * @return Updated details of the observation
     */
    update(command: ObservationUpdateCommand): Observable<GetObservationDetailsResponseItem>;
    /**
     * Get  details for a specific observation
     * @param id GUID of a observation
     * @return Observation details
     */
    get(id: string): Observable<GetObservationDetailsResponseItem>;
}

@Injectable({
    providedIn: 'root'
})
export class ObservationsClient implements IObservationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Get observations for given observation ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetObservationDetailsResponseItem[]> {
        let url_ = this.baseUrl + "/Observations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultiple(<any>response_);
                } catch (e) {
                    return <Observable<GetObservationDetailsResponseItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObservationDetailsResponseItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMultiple(response: HttpResponseBase): Observable<GetObservationDetailsResponseItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetObservationDetailsResponseItem.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObservationDetailsResponseItem[]>(<any>null);
    }

    /**
     * Updates an observation
     * @param command A command for archiving observation or updating remarks
     * @return Updated details of the observation
     */
    update(command: ObservationUpdateCommand): Observable<GetObservationDetailsResponseItem> {
        let url_ = this.baseUrl + "/Observations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GetObservationDetailsResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetObservationDetailsResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObservationDetailsResponseItem>(<any>null);
    }

    /**
     * Get  details for a specific observation
     * @param id GUID of a observation
     * @return Observation details
     */
    get(id: string): Observable<GetObservationDetailsResponseItem> {
        let url_ = this.baseUrl + "/Observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetObservationDetailsResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetObservationDetailsResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObservationDetailsResponseItem>(<any>null);
    }
}

export interface IMapsClient {
    /**
     * Gets listing of all available overlay layers
     * @param orderedLayerCategoryCodes (optional) Category of layer
     * @param year (optional) Specific layers need year on which they get data
     * @param numberOfYears (optional) Maximum years go back in history
     * @return List of layers
     */
    overlayLayers(orderedLayerCategoryCodes: OverlayLayerCategoryCode[] | null | undefined, year: number | undefined, numberOfYears: number | undefined): Observable<ListResponseOfGetOverlayLayersResponseItem>;
    /**
     * Gets listing of all available background layers
     * @param query (optional) 
     * @return List of layers
     */
    backgroundLayers(query: GetBackgroundLayersQuery | null | undefined): Observable<ListResponseOfGetBackgroundLayersResponseItem>;
    /**
     * Gets listing of all map styles
     * @return List of map styles
     */
    styles(): Observable<GetMapStylesResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class MapsClient implements IMapsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available overlay layers
     * @param orderedLayerCategoryCodes (optional) Category of layer
     * @param year (optional) Specific layers need year on which they get data
     * @param numberOfYears (optional) Maximum years go back in history
     * @return List of layers
     */
    overlayLayers(orderedLayerCategoryCodes: OverlayLayerCategoryCode[] | null | undefined, year: number | undefined, numberOfYears: number | undefined): Observable<ListResponseOfGetOverlayLayersResponseItem> {
        let url_ = this.baseUrl + "/Maps/overlay-layers?";
        if (orderedLayerCategoryCodes !== undefined && orderedLayerCategoryCodes !== null)
            orderedLayerCategoryCodes && orderedLayerCategoryCodes.forEach(item => { url_ += "OrderedLayerCategoryCodes=" + encodeURIComponent("" + item) + "&"; });
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (numberOfYears === null)
            throw new Error("The parameter 'numberOfYears' cannot be null.");
        else if (numberOfYears !== undefined)
            url_ += "NumberOfYears=" + encodeURIComponent("" + numberOfYears) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOverlayLayers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOverlayLayers(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetOverlayLayersResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetOverlayLayersResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processOverlayLayers(response: HttpResponseBase): Observable<ListResponseOfGetOverlayLayersResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetOverlayLayersResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetOverlayLayersResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available background layers
     * @param query (optional) 
     * @return List of layers
     */
    backgroundLayers(query: GetBackgroundLayersQuery | null | undefined): Observable<ListResponseOfGetBackgroundLayersResponseItem> {
        let url_ = this.baseUrl + "/Maps/background-layers?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackgroundLayers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackgroundLayers(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetBackgroundLayersResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetBackgroundLayersResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processBackgroundLayers(response: HttpResponseBase): Observable<ListResponseOfGetBackgroundLayersResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetBackgroundLayersResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetBackgroundLayersResponseItem>(<any>null);
    }

    /**
     * Gets listing of all map styles
     * @return List of map styles
     */
    styles(): Observable<GetMapStylesResponse> {
        let url_ = this.baseUrl + "/Maps/styles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStyles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStyles(<any>response_);
                } catch (e) {
                    return <Observable<GetMapStylesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMapStylesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStyles(response: HttpResponseBase): Observable<GetMapStylesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMapStylesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMapStylesResponse>(<any>null);
    }
}

export interface ILookupsClient {
    /**
     * Gets listing of all available Trapping types
     * @return List of trap types
     */
    trappingTypes(): Observable<ListResponseOfGetTrappingTypesResponseItem>;
    /**
     * Gets listing of all available Trap types
     * @param query (optional) 
     * @return List of trap types
     */
    trapTypes(query: GetTrapTypesQuery | null | undefined): Observable<ListResponseOfGetTrapTypesResponseItem>;
    /**
     * Gets listing of all available Catch types
     * @param query (optional) 
     * @return List of catch types
     */
    catchTypes(query: GetCatchTypesQuery | null | undefined): Observable<ListResponseOfGetCatchTypesResponseItem>;
    /**
     * Gets listing of all available time registration categories
     * @return List of time registration categories
     */
    timeRegistrationCategories(): Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem>;
}

@Injectable({
    providedIn: 'root'
})
export class LookupsClient implements ILookupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available Trapping types
     * @return List of trap types
     */
    trappingTypes(): Observable<ListResponseOfGetTrappingTypesResponseItem> {
        let url_ = this.baseUrl + "/trapping-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrappingTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrappingTypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetTrappingTypesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetTrappingTypesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processTrappingTypes(response: HttpResponseBase): Observable<ListResponseOfGetTrappingTypesResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetTrappingTypesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetTrappingTypesResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available Trap types
     * @param query (optional) 
     * @return List of trap types
     */
    trapTypes(query: GetTrapTypesQuery | null | undefined): Observable<ListResponseOfGetTrapTypesResponseItem> {
        let url_ = this.baseUrl + "/trap-types?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrapTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrapTypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetTrapTypesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetTrapTypesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processTrapTypes(response: HttpResponseBase): Observable<ListResponseOfGetTrapTypesResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetTrapTypesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetTrapTypesResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available Catch types
     * @param query (optional) 
     * @return List of catch types
     */
    catchTypes(query: GetCatchTypesQuery | null | undefined): Observable<ListResponseOfGetCatchTypesResponseItem> {
        let url_ = this.baseUrl + "/catch-types?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCatchTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCatchTypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetCatchTypesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetCatchTypesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processCatchTypes(response: HttpResponseBase): Observable<ListResponseOfGetCatchTypesResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetCatchTypesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetCatchTypesResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available time registration categories
     * @return List of time registration categories
     */
    timeRegistrationCategories(): Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem> {
        let url_ = this.baseUrl + "/time-registration-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimeRegistrationCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimeRegistrationCategories(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processTimeRegistrationCategories(response: HttpResponseBase): Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetTimeRegistrationCategoriesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetTimeRegistrationCategoriesResponseItem>(<any>null);
    }
}

export interface IFieldTestsClient {
    /**
     * Gets listing of all available field tests info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of Field tests
     */
    searchFieldTests(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetFieldTestResponse>;
    /**
     * Creates or updates field tests
     * @param command Field test data
     */
    post(command: FieldTestCreateOrUpdateCommand): Observable<GetFieldTestResponse>;
    /**
     * Get field test details for given id
     * @param id Id
     */
    get(id: string): Observable<GetFieldTestResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FieldTestsClient implements IFieldTestsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available field tests info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of Field tests
     */
    searchFieldTests(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetFieldTestResponse> {
        let url_ = this.baseUrl + "/FieldTests?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchFieldTests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFieldTests(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetFieldTestResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetFieldTestResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSearchFieldTests(response: HttpResponseBase): Observable<PagedResponseOfGetFieldTestResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetFieldTestResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetFieldTestResponse>(<any>null);
    }

    /**
     * Creates or updates field tests
     * @param command Field test data
     */
    post(command: FieldTestCreateOrUpdateCommand): Observable<GetFieldTestResponse> {
        let url_ = this.baseUrl + "/FieldTests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetFieldTestResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFieldTestResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetFieldTestResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFieldTestResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFieldTestResponse>(<any>null);
    }

    /**
     * Get field test details for given id
     * @param id Id
     */
    get(id: string): Observable<GetFieldTestResponse> {
        let url_ = this.baseUrl + "/FieldTests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetFieldTestResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFieldTestResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetFieldTestResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFieldTestResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFieldTestResponse>(<any>null);
    }
}

export interface ICatchTypesClient {
    /**
     * Gets listing of all available Catch types info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of Catch types
     */
    searchCatchType(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetCatchTypeResponse>;
    /**
     * Creates or updates a catch type
     * @param command Catch type data
     */
    post(command: CatchTypeCreateOrUpdateCommand): Observable<GetCatchTypeResponse>;
    /**
     * Get trap type details for given id
     * @param id Id
     */
    get(id: string): Observable<GetCatchTypeResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CatchTypesClient implements ICatchTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets listing of all available Catch types info
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     * @return List of Catch types
     */
    searchCatchType(keyword: string | null | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetCatchTypeResponse> {
        let url_ = this.baseUrl + "/CatchTypes?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCatchType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCatchType(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetCatchTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetCatchTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSearchCatchType(response: HttpResponseBase): Observable<PagedResponseOfGetCatchTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetCatchTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetCatchTypeResponse>(<any>null);
    }

    /**
     * Creates or updates a catch type
     * @param command Catch type data
     */
    post(command: CatchTypeCreateOrUpdateCommand): Observable<GetCatchTypeResponse> {
        let url_ = this.baseUrl + "/CatchTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetCatchTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCatchTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetCatchTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCatchTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCatchTypeResponse>(<any>null);
    }

    /**
     * Get trap type details for given id
     * @param id Id
     */
    get(id: string): Observable<GetCatchTypeResponse> {
        let url_ = this.baseUrl + "/CatchTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetCatchTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCatchTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetCatchTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCatchTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCatchTypeResponse>(<any>null);
    }
}

export interface ICatchesClient {
    /**
     * Get catch for given id
     * @param id Id
     */
    get(id: string): Observable<GetCatchDetailsCatchItem>;
    /**
     * Physically delete catch
     * @param id Catch id
     */
    delete(id: string): Observable<void>;
    /**
     * Updates a catch
     * @param command Catch data
     */
    put(command: CatchCreateOrUpdateCommand): Observable<GetCatchDetailsCatchItem>;
}

@Injectable({
    providedIn: 'root'
})
export class CatchesClient implements ICatchesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Get catch for given id
     * @param id Id
     */
    get(id: string): Observable<GetCatchDetailsCatchItem> {
        let url_ = this.baseUrl + "/Catches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetCatchDetailsCatchItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCatchDetailsCatchItem>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetCatchDetailsCatchItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCatchDetailsCatchItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCatchDetailsCatchItem>(<any>null);
    }

    /**
     * Physically delete catch
     * @param id Catch id
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/Catches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Updates a catch
     * @param command Catch data
     */
    put(command: CatchCreateOrUpdateCommand): Observable<GetCatchDetailsCatchItem> {
        let url_ = this.baseUrl + "/Catches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<GetCatchDetailsCatchItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCatchDetailsCatchItem>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<GetCatchDetailsCatchItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCatchDetailsCatchItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCatchDetailsCatchItem>(<any>null);
    }
}

export interface IAreasClient {
    /**
     * Get CatchAreas based on filter and RayonId
     * @param filter (optional) The string used to filter CatchAreas by Name
     * @param rayonId (optional) The RayonId of the requested CatchAreas
     * @param filterByOrganization (optional) Flag that represents whether CatchAreas should be filtered by organization of current user
     */
    getCatchAreas(filter: string | null | undefined, rayonId: string | null | undefined, filterByOrganization: boolean | undefined): Observable<GetAreaEntitiesResponse>;
    /**
     * Get HourSquares based on filter and SubAreaId
     * @param filter (optional) The string used to filter HourSquares by Name
     * @param subAreaId (optional) The SubAreaId based on which to filter HourSquares
     */
    getHourSquares(filter: string | null | undefined, subAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse>;
    /**
     * Get SubAreas based on filter and CatchAreaId
     * @param filter (optional) The string used to filter SubAreas by Name
     * @param catchAreaId (optional) The CatchAreaId of the requested SubAreas
     */
    getSubAreas(filter: string | null | undefined, catchAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AreasClient implements IAreasClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Get CatchAreas based on filter and RayonId
     * @param filter (optional) The string used to filter CatchAreas by Name
     * @param rayonId (optional) The RayonId of the requested CatchAreas
     * @param filterByOrganization (optional) Flag that represents whether CatchAreas should be filtered by organization of current user
     */
    getCatchAreas(filter: string | null | undefined, rayonId: string | null | undefined, filterByOrganization: boolean | undefined): Observable<GetAreaEntitiesResponse> {
        let url_ = this.baseUrl + "/Areas/catch-areas?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (rayonId !== undefined && rayonId !== null)
            url_ += "rayonId=" + encodeURIComponent("" + rayonId) + "&";
        if (filterByOrganization === null)
            throw new Error("The parameter 'filterByOrganization' cannot be null.");
        else if (filterByOrganization !== undefined)
            url_ += "filterByOrganization=" + encodeURIComponent("" + filterByOrganization) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatchAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatchAreas(<any>response_);
                } catch (e) {
                    return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCatchAreas(response: HttpResponseBase): Observable<GetAreaEntitiesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAreaEntitiesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaEntitiesResponse>(<any>null);
    }

    /**
     * Get HourSquares based on filter and SubAreaId
     * @param filter (optional) The string used to filter HourSquares by Name
     * @param subAreaId (optional) The SubAreaId based on which to filter HourSquares
     */
    getHourSquares(filter: string | null | undefined, subAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse> {
        let url_ = this.baseUrl + "/Areas/hour-squares?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (subAreaId !== undefined && subAreaId !== null)
            url_ += "subAreaId=" + encodeURIComponent("" + subAreaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHourSquares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHourSquares(<any>response_);
                } catch (e) {
                    return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetHourSquares(response: HttpResponseBase): Observable<GetAreaEntitiesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAreaEntitiesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaEntitiesResponse>(<any>null);
    }

    /**
     * Get SubAreas based on filter and CatchAreaId
     * @param filter (optional) The string used to filter SubAreas by Name
     * @param catchAreaId (optional) The CatchAreaId of the requested SubAreas
     */
    getSubAreas(filter: string | null | undefined, catchAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse> {
        let url_ = this.baseUrl + "/Areas/sub-areas?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (catchAreaId !== undefined && catchAreaId !== null)
            url_ += "catchAreaId=" + encodeURIComponent("" + catchAreaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubAreas(<any>response_);
                } catch (e) {
                    return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubAreas(response: HttpResponseBase): Observable<GetAreaEntitiesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAreaEntitiesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaEntitiesResponse>(<any>null);
    }
}

export interface IAccountClient {
    /**
     * Gets profile of the user
     * @return User profile as known in application
     */
    getUserProfile(): Observable<GetCurrentUserProfileResponse>;
    /**
     * Creates user from Azure AD profile. (name, surname and email (UPN))
     * @return Notification if user creation was successful. ProblemDetail class (.NET Core) in case of error.
     */
    createUserFromIdentity(): Observable<AutoCreateUserAfterLoginResult>;
    /**
     * Logout user from the application with his Azure AD account
     * @return User email when logout is successful
     */
    logOut(): Observable<UserSessionTerminateResult>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5440";
    }

    /**
     * Gets profile of the user
     * @return User profile as known in application
     */
    getUserProfile(): Observable<GetCurrentUserProfileResponse> {
        let url_ = this.baseUrl + "/Account/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentUserProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentUserProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<GetCurrentUserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentUserProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentUserProfileResponse>(<any>null);
    }

    /**
     * Creates user from Azure AD profile. (name, surname and email (UPN))
     * @return Notification if user creation was successful. ProblemDetail class (.NET Core) in case of error.
     */
    createUserFromIdentity(): Observable<AutoCreateUserAfterLoginResult> {
        let url_ = this.baseUrl + "/Account/initiate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserFromIdentity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserFromIdentity(<any>response_);
                } catch (e) {
                    return <Observable<AutoCreateUserAfterLoginResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AutoCreateUserAfterLoginResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserFromIdentity(response: HttpResponseBase): Observable<AutoCreateUserAfterLoginResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoCreateUserAfterLoginResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoCreateUserAfterLoginResult>(<any>null);
    }

    /**
     * Logout user from the application with his Azure AD account
     * @return User email when logout is successful
     */
    logOut(): Observable<UserSessionTerminateResult> {
        let url_ = this.baseUrl + "/Account/log-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<UserSessionTerminateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSessionTerminateResult>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<UserSessionTerminateResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSessionTerminateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSessionTerminateResult>(<any>null);
    }
}

export class GetRolesResponse implements IGetRolesResponse {
    items?: GetRolesResponseItem[];

    constructor(data?: IGetRolesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRolesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRolesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRolesResponse {
    items?: GetRolesResponseItem[];
}

export class GetRolesResponseItem implements IGetRolesResponseItem {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string | undefined;
    /** Indication whether current user can assign this role to him */
    canCurrentUserChangeToThisRole?: boolean;
    /** List of permission the user has with his roles */
    permissions?: GetRolesResponsePermission[] | undefined;

    constructor(data?: IGetRolesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.canCurrentUserChangeToThisRole = _data["canCurrentUserChangeToThisRole"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(GetRolesResponsePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRolesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["canCurrentUserChangeToThisRole"] = this.canCurrentUserChangeToThisRole;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRolesResponseItem {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string | undefined;
    /** Indication whether current user can assign this role to him */
    canCurrentUserChangeToThisRole?: boolean;
    /** List of permission the user has with his roles */
    permissions?: GetRolesResponsePermission[] | undefined;
}

export class GetRolesResponsePermission implements IGetRolesResponsePermission {
    id?: PermissionId;
    name?: string | undefined;
    assignedToRole?: boolean;
    canBeChanged?: boolean;

    constructor(data?: IGetRolesResponsePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.assignedToRole = _data["assignedToRole"];
            this.canBeChanged = _data["canBeChanged"];
        }
    }

    static fromJS(data: any): GetRolesResponsePermission {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesResponsePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["assignedToRole"] = this.assignedToRole;
        data["canBeChanged"] = this.canBeChanged;
        return data; 
    }
}

export interface IGetRolesResponsePermission {
    id?: PermissionId;
    name?: string | undefined;
    assignedToRole?: boolean;
    canBeChanged?: boolean;
}

export enum PermissionId {
    MapRead = 1,
    MapContentRead = 2,
    MapContentWrite = 3,
    ReportReadWrite = 4,
    TimeRegistrationPersonalReadWrite = 5,
    TimeRegistrationManagementReadWrite = 6,
    UserReadWrite = 7,
    Management = 8,
    AssignMaintainerRole = 9,
    ReadOnly = 10,
    ApiPublic = 11,
    ApiPrivate = 12,
    Mobile = 100,
}

export class GetRolesQuery implements IGetRolesQuery {

    constructor(data?: IGetRolesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetRolesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetRolesQuery {
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class UpdateRolesPermissionsCommand implements IUpdateRolesPermissionsCommand {
    roles?: UpdateRolesPermissionsCommandItem[];

    constructor(data?: IUpdateRolesPermissionsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UpdateRolesPermissionsCommandItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateRolesPermissionsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolesPermissionsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateRolesPermissionsCommand {
    roles?: UpdateRolesPermissionsCommandItem[];
}

export class UpdateRolesPermissionsCommandItem implements IUpdateRolesPermissionsCommandItem {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string;
    /** New permission list to be assigned to this role */
    permissionIds?: PermissionId[];

    constructor(data?: IUpdateRolesPermissionsCommandItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolesPermissionsCommandItem {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolesPermissionsCommandItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRolesPermissionsCommandItem {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string;
    /** New permission list to be assigned to this role */
    permissionIds?: PermissionId[];
}

export class PagedResponseOfGetUsersResponseItem implements IPagedResponseOfGetUsersResponseItem {
    items?: GetUsersResponseItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetUsersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetUsersResponseItem.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetUsersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetUsersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetUsersResponseItem {
    items?: GetUsersResponseItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetUsersResponseItem implements IGetUsersResponseItem {
    /** GUID of user */
    id?: string;
    /** Full name of the user */
    name?: string;
    /** Email, which is also account id */
    email?: string;
    /** Surname */
    surname?: string;
    /** Givenname, sometimes consists only of initials */
    givenName?: string;
    /** Indicator whether user is given access to the application */
    authorized?: boolean;
    /** Indication whether user complied with the organization policies to use application */
    confidentialityConfirmed?: boolean;
    /** Datetime this user has been created */
    createdOn?: Date;
    /** Date when some data has been changed for this user */
    updatedOn?: Date;
    /** Date when the user has been revoked access. This is used for annonymization purposes. */
    inactiveOn?: Date | undefined;
    /** List of roles that are assigned to the user */
    roles?: GetUsersResponseItemRole[];
    /** Organization name user belongs to */
    organizationName?: string;
    /** Organization guid user belongs to */
    organizationId?: string | undefined;

    constructor(data?: IGetUsersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.surname = _data["surname"];
            this.givenName = _data["givenName"];
            this.authorized = _data["authorized"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.inactiveOn = _data["inactiveOn"] ? new Date(_data["inactiveOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(GetUsersResponseItemRole.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): GetUsersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["surname"] = this.surname;
        data["givenName"] = this.givenName;
        data["authorized"] = this.authorized;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["inactiveOn"] = this.inactiveOn ? this.inactiveOn.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IGetUsersResponseItem {
    /** GUID of user */
    id?: string;
    /** Full name of the user */
    name?: string;
    /** Email, which is also account id */
    email?: string;
    /** Surname */
    surname?: string;
    /** Givenname, sometimes consists only of initials */
    givenName?: string;
    /** Indicator whether user is given access to the application */
    authorized?: boolean;
    /** Indication whether user complied with the organization policies to use application */
    confidentialityConfirmed?: boolean;
    /** Datetime this user has been created */
    createdOn?: Date;
    /** Date when some data has been changed for this user */
    updatedOn?: Date;
    /** Date when the user has been revoked access. This is used for annonymization purposes. */
    inactiveOn?: Date | undefined;
    /** List of roles that are assigned to the user */
    roles?: GetUsersResponseItemRole[];
    /** Organization name user belongs to */
    organizationName?: string;
    /** Organization guid user belongs to */
    organizationId?: string | undefined;
}

export class GetUsersResponseItemRole implements IGetUsersResponseItemRole {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string | undefined;

    constructor(data?: IGetUsersResponseItemRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetUsersResponseItemRole {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersResponseItemRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetUsersResponseItemRole {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string | undefined;
}

export class GetUserDetailsResponse implements IGetUserDetailsResponse {
    /** GUID of user */
    id?: string;
    /** Full name of the user */
    name?: string;
    /** Email, which is also account id */
    email?: string;
    /** Surname */
    surname?: string;
    /** Givenname, sometimes consists only of initials */
    givenName?: string;
    /** Indicator whether user is given access to the application */
    authorized?: boolean;
    /** Datetime this user has been created */
    createdOn?: Date;
    /** Date when some data has been changed for this user */
    updatedOn?: Date;
    /** List of roles that are assigned to the user */
    roles?: GetUserDetailsResponseRole[];
    /** Organization name user belongs to */
    organizationName?: string;
    /** Indication whether user complied with the organization policies to use application */
    confidentialityConfirmed?: boolean;
    /** Date when the user has been revoked access. This is used for annonymization purposes. */
    inactiveOn?: Date;

    constructor(data?: IGetUserDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.surname = _data["surname"];
            this.givenName = _data["givenName"];
            this.authorized = _data["authorized"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(GetUserDetailsResponseRole.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
            this.inactiveOn = _data["inactiveOn"] ? new Date(_data["inactiveOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["surname"] = this.surname;
        data["givenName"] = this.givenName;
        data["authorized"] = this.authorized;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        data["inactiveOn"] = this.inactiveOn ? this.inactiveOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetUserDetailsResponse {
    /** GUID of user */
    id?: string;
    /** Full name of the user */
    name?: string;
    /** Email, which is also account id */
    email?: string;
    /** Surname */
    surname?: string;
    /** Givenname, sometimes consists only of initials */
    givenName?: string;
    /** Indicator whether user is given access to the application */
    authorized?: boolean;
    /** Datetime this user has been created */
    createdOn?: Date;
    /** Date when some data has been changed for this user */
    updatedOn?: Date;
    /** List of roles that are assigned to the user */
    roles?: GetUserDetailsResponseRole[];
    /** Organization name user belongs to */
    organizationName?: string;
    /** Indication whether user complied with the organization policies to use application */
    confidentialityConfirmed?: boolean;
    /** Date when the user has been revoked access. This is used for annonymization purposes. */
    inactiveOn?: Date;
}

export class GetUserDetailsResponseRole implements IGetUserDetailsResponseRole {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string;
    /** Set of permission user has acquired through assigned roles */
    permissions?: GetUserDetailsResponsePermission[];

    constructor(data?: IGetUserDetailsResponseRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(GetUserDetailsResponsePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserDetailsResponseRole {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsResponseRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserDetailsResponseRole {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string;
    /** Set of permission user has acquired through assigned roles */
    permissions?: GetUserDetailsResponsePermission[];
}

export class GetUserDetailsResponsePermission implements IGetUserDetailsResponsePermission {
    /** GUID of permission */
    id?: PermissionId;
    /** Name of the permission */
    name?: string;

    constructor(data?: IGetUserDetailsResponsePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetUserDetailsResponsePermission {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsResponsePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetUserDetailsResponsePermission {
    /** GUID of permission */
    id?: PermissionId;
    /** Name of the permission */
    name?: string;
}

export class UserUpdateCommand implements IUserUpdateCommand {
    /** GUID of the user */
    id?: string;
    /** Indicator whether user is authorized for access */
    authorized?: boolean;
    /** Organization id of the organization user will be assigned to */
    organizationId?: string | undefined;

    constructor(data?: IUserUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorized = _data["authorized"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): UserUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorized"] = this.authorized;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IUserUpdateCommand {
    /** GUID of the user */
    id?: string;
    /** Indicator whether user is authorized for access */
    authorized?: boolean;
    /** Organization id of the organization user will be assigned to */
    organizationId?: string | undefined;
}

export class UpdateUserRolesCommand implements IUpdateUserRolesCommand {
    /** GUID of the user */
    id?: string;
    /** List of roles user will be assigned to */
    roles?: string[];

    constructor(data?: IUpdateUserRolesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserRolesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRolesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserRolesCommand {
    /** GUID of the user */
    id?: string;
    /** List of roles user will be assigned to */
    roles?: string[];
}

export class UserUpdateConfidentialityCommand implements IUserUpdateConfidentialityCommand {
    /** GUID of the user */
    id?: string;
    /** Indicator whether user agreed with organization policies */
    confidentialityConfirmed?: boolean;

    constructor(data?: IUserUpdateConfidentialityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
        }
    }

    static fromJS(data: any): UserUpdateConfidentialityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateConfidentialityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        return data; 
    }
}

export interface IUserUpdateConfidentialityCommand {
    /** GUID of the user */
    id?: string;
    /** Indicator whether user agreed with organization policies */
    confidentialityConfirmed?: boolean;
}

export class PagedResponseOfGetTrapTypeResponse implements IPagedResponseOfGetTrapTypeResponse {
    items?: GetTrapTypeResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetTrapTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrapTypeResponse.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetTrapTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetTrapTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetTrapTypeResponse {
    items?: GetTrapTypeResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetTrapTypeResponse implements IGetTrapTypeResponse {
    /** GUID of trap type */
    id?: string;
    /** Name of the trap type */
    name?: string;
    /** GUID of the trapping type this trap type is used for */
    trappingTypeId?: string;
    /** Name of the trapping type this trap type is used for */
    trappingType?: string;
    /** Indicator whether trap type is active */
    active?: boolean;
    /** Order number used for showing trap type in the list on mobile app */
    order?: number;

    constructor(data?: IGetTrapTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.trappingTypeId = _data["trappingTypeId"];
            this.trappingType = _data["trappingType"];
            this.active = _data["active"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): GetTrapTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["trappingTypeId"] = this.trappingTypeId;
        data["trappingType"] = this.trappingType;
        data["active"] = this.active;
        data["order"] = this.order;
        return data; 
    }
}

export interface IGetTrapTypeResponse {
    /** GUID of trap type */
    id?: string;
    /** Name of the trap type */
    name?: string;
    /** GUID of the trapping type this trap type is used for */
    trappingTypeId?: string;
    /** Name of the trapping type this trap type is used for */
    trappingType?: string;
    /** Indicator whether trap type is active */
    active?: boolean;
    /** Order number used for showing trap type in the list on mobile app */
    order?: number;
}

export class TrapTypeCreateOrUpdateCommand implements ITrapTypeCreateOrUpdateCommand {
    /** Indicator whether trap type is active */
    active?: boolean;
    /** GUID of the trap type */
    id?: string | undefined;
    /** Name of the trap type */
    name?: string;
    /** Order number used for showing trap type in the list on mobile app */
    order?: number;
    /** GUID of the trapping type this trap type is used for */
    trappingTypeId?: string;
    /** Indicator whether Trap of this type can be in status Not-catching */
    allowNotCatching?: boolean;

    constructor(data?: ITrapTypeCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.trappingTypeId = _data["trappingTypeId"];
            this.allowNotCatching = _data["allowNotCatching"];
        }
    }

    static fromJS(data: any): TrapTypeCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TrapTypeCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["trappingTypeId"] = this.trappingTypeId;
        data["allowNotCatching"] = this.allowNotCatching;
        return data; 
    }
}

export interface ITrapTypeCreateOrUpdateCommand {
    /** Indicator whether trap type is active */
    active?: boolean;
    /** GUID of the trap type */
    id?: string | undefined;
    /** Name of the trap type */
    name?: string;
    /** Order number used for showing trap type in the list on mobile app */
    order?: number;
    /** GUID of the trapping type this trap type is used for */
    trappingTypeId?: string;
    /** Indicator whether Trap of this type can be in status Not-catching */
    allowNotCatching?: boolean;
}

export class GetTrapDetailsTrapItem implements IGetTrapDetailsTrapItem {
    /** GUID of trap */
    id?: string;
    /** Name of the trap type */
    type?: string;
    /** GUID of the trap type */
    trapTypeId?: string;
    /** GUID of the trapping type */
    trappingTypeId?: string;
    /** Trap status: catching, non catching, deleted */
    status?: TrapStatus;
    /** Remarks entered by a trapper */
    remarks?: string | undefined;
    /** Number of traps */
    numberOfTraps?: number;
    /** Longitude of trap where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
    /** Name of user who created this trap */
    createdBy?: string;
    /** Created on of record in back-office */
    createdOn?: Date;
    /** Date when the trap has been created on mobile by trapper */
    recordedOn?: Date;
    /** Name of user who updated this trap */
    updatedBy?: string;
    /** Updated on */
    updatedOn?: Date;
    /** List of catch detail on this trap */
    catches?: GetCatchDetailsCatchItem[];
    /** Rayon */
    rayon?: string;
    /** Sub Area */
    subArea?: string;
    /** Cath Area */
    catchArea?: string;
    /** GUID of the user who created this trap */
    createdById?: string;

    constructor(data?: IGetTrapDetailsTrapItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.trapTypeId = _data["trapTypeId"];
            this.trappingTypeId = _data["trappingTypeId"];
            this.status = _data["status"];
            this.remarks = _data["remarks"];
            this.numberOfTraps = _data["numberOfTraps"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["catches"])) {
                this.catches = [] as any;
                for (let item of _data["catches"])
                    this.catches!.push(GetCatchDetailsCatchItem.fromJS(item));
            }
            this.rayon = _data["rayon"];
            this.subArea = _data["subArea"];
            this.catchArea = _data["catchArea"];
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): GetTrapDetailsTrapItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapDetailsTrapItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["trapTypeId"] = this.trapTypeId;
        data["trappingTypeId"] = this.trappingTypeId;
        data["status"] = this.status;
        data["remarks"] = this.remarks;
        data["numberOfTraps"] = this.numberOfTraps;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        if (Array.isArray(this.catches)) {
            data["catches"] = [];
            for (let item of this.catches)
                data["catches"].push(item.toJSON());
        }
        data["rayon"] = this.rayon;
        data["subArea"] = this.subArea;
        data["catchArea"] = this.catchArea;
        data["createdById"] = this.createdById;
        return data; 
    }
}

export interface IGetTrapDetailsTrapItem {
    /** GUID of trap */
    id?: string;
    /** Name of the trap type */
    type?: string;
    /** GUID of the trap type */
    trapTypeId?: string;
    /** GUID of the trapping type */
    trappingTypeId?: string;
    /** Trap status: catching, non catching, deleted */
    status?: TrapStatus;
    /** Remarks entered by a trapper */
    remarks?: string | undefined;
    /** Number of traps */
    numberOfTraps?: number;
    /** Longitude of trap where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
    /** Name of user who created this trap */
    createdBy?: string;
    /** Created on of record in back-office */
    createdOn?: Date;
    /** Date when the trap has been created on mobile by trapper */
    recordedOn?: Date;
    /** Name of user who updated this trap */
    updatedBy?: string;
    /** Updated on */
    updatedOn?: Date;
    /** List of catch detail on this trap */
    catches?: GetCatchDetailsCatchItem[];
    /** Rayon */
    rayon?: string;
    /** Sub Area */
    subArea?: string;
    /** Cath Area */
    catchArea?: string;
    /** GUID of the user who created this trap */
    createdById?: string;
}

export enum TrapStatus {
    Catching = 1,
    NotCatching = 2,
    Removed = 3,
}

export class GetCatchDetailsCatchItem implements IGetCatchDetailsCatchItem {
    /** GUID of catch */
    id?: string;
    /** Name of the type of catch */
    type?: string;
    /** Catch Area */
    catchArea?: NamedEntityItem;
    /** Sub Area */
    subArea?: NamedEntityItem;
    /** Hour Square (Atlas Block) */
    hourSquare?: NamedEntityItem;
    /** Number of catches of this type */
    number?: number;
    /** Indicator catch or by-catch */
    isByCatch?: boolean;
    /** Name of the user who created the catch */
    createdBy?: string;
    /** GUID of the user who created the catch */
    createdById?: string;
    /** Date when the catch is stored in database */
    createdOn?: Date;
    /** Date when the catch is registered on mobile */
    recordedOn?: Date;
    /** GUID of the catch type */
    catchTypeId?: string;
    /** Catch status: written, closed, completed */
    status?: CatchStatus;
    /** Indicator weather catch can be edited */
    canBeEdited?: boolean;

    constructor(data?: IGetCatchDetailsCatchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.catchArea = _data["catchArea"] ? NamedEntityItem.fromJS(_data["catchArea"]) : <any>undefined;
            this.subArea = _data["subArea"] ? NamedEntityItem.fromJS(_data["subArea"]) : <any>undefined;
            this.hourSquare = _data["hourSquare"] ? NamedEntityItem.fromJS(_data["hourSquare"]) : <any>undefined;
            this.number = _data["number"];
            this.isByCatch = _data["isByCatch"];
            this.createdBy = _data["createdBy"];
            this.createdById = _data["createdById"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.catchTypeId = _data["catchTypeId"];
            this.status = _data["status"];
            this.canBeEdited = _data["canBeEdited"];
        }
    }

    static fromJS(data: any): GetCatchDetailsCatchItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchDetailsCatchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["catchArea"] = this.catchArea ? this.catchArea.toJSON() : <any>undefined;
        data["subArea"] = this.subArea ? this.subArea.toJSON() : <any>undefined;
        data["hourSquare"] = this.hourSquare ? this.hourSquare.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["isByCatch"] = this.isByCatch;
        data["createdBy"] = this.createdBy;
        data["createdById"] = this.createdById;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["catchTypeId"] = this.catchTypeId;
        data["status"] = this.status;
        data["canBeEdited"] = this.canBeEdited;
        return data; 
    }
}

export interface IGetCatchDetailsCatchItem {
    /** GUID of catch */
    id?: string;
    /** Name of the type of catch */
    type?: string;
    /** Catch Area */
    catchArea?: NamedEntityItem;
    /** Sub Area */
    subArea?: NamedEntityItem;
    /** Hour Square (Atlas Block) */
    hourSquare?: NamedEntityItem;
    /** Number of catches of this type */
    number?: number;
    /** Indicator catch or by-catch */
    isByCatch?: boolean;
    /** Name of the user who created the catch */
    createdBy?: string;
    /** GUID of the user who created the catch */
    createdById?: string;
    /** Date when the catch is stored in database */
    createdOn?: Date;
    /** Date when the catch is registered on mobile */
    recordedOn?: Date;
    /** GUID of the catch type */
    catchTypeId?: string;
    /** Catch status: written, closed, completed */
    status?: CatchStatus;
    /** Indicator weather catch can be edited */
    canBeEdited?: boolean;
}

export class NamedEntityItem implements INamedEntityItem {
    id?: string;
    name?: string;

    constructor(data?: INamedEntityItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NamedEntityItem {
        data = typeof data === 'object' ? data : {};
        let result = new NamedEntityItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface INamedEntityItem {
    id?: string;
    name?: string;
}

export enum CatchStatus {
    Written = 1,
    Closed = 2,
    Completed = 3,
}

export class TrapUpdateCommand implements ITrapUpdateCommand {
    /** GUID of the trap */
    id!: string;
    /** GUID of the (new) trap type */
    trapTypeId!: string;
    /** Indicator of trap status: catching, non catching or deleted */
    status!: TrapStatus;
    /** Longitude of trap where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
    /** Remarks that apply to this trap, entered by a trapper */
    remarks?: string | undefined;

    constructor(data?: ITrapUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trapTypeId = _data["trapTypeId"];
            this.status = _data["status"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): TrapUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TrapUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trapTypeId"] = this.trapTypeId;
        data["status"] = this.status;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["remarks"] = this.remarks;
        return data; 
    }
}

export interface ITrapUpdateCommand {
    /** GUID of the trap */
    id: string;
    /** GUID of the (new) trap type */
    trapTypeId: string;
    /** Indicator of trap status: catching, non catching or deleted */
    status: TrapStatus;
    /** Longitude of trap where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
    /** Remarks that apply to this trap, entered by a trapper */
    remarks?: string | undefined;
}

export class ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse implements IListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse {
    items?: GetVersionRegionalLayoutsVersionRegionalLayoutResponse[];

    constructor(data?: IListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetVersionRegionalLayoutsVersionRegionalLayoutResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetVersionRegionalLayoutsVersionRegionalLayoutResponse {
    items?: GetVersionRegionalLayoutsVersionRegionalLayoutResponse[];
}

export class GetVersionRegionalLayoutsVersionRegionalLayoutResponse implements IGetVersionRegionalLayoutsVersionRegionalLayoutResponse {
    id?: string;
    name?: string;
    startDate?: Date;

    constructor(data?: IGetVersionRegionalLayoutsVersionRegionalLayoutResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVersionRegionalLayoutsVersionRegionalLayoutResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVersionRegionalLayoutsVersionRegionalLayoutResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetVersionRegionalLayoutsVersionRegionalLayoutResponse {
    id?: string;
    name?: string;
    startDate?: Date;
}

export class GetScheduledJobsResponse implements IGetScheduledJobsResponse {
    id?: string | undefined;
    name?: ScheduledJobName;
    state?: ScheduledJobState;
    outputMessages?: string[];

    constructor(data?: IGetScheduledJobsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            if (Array.isArray(_data["outputMessages"])) {
                this.outputMessages = [] as any;
                for (let item of _data["outputMessages"])
                    this.outputMessages!.push(item);
            }
        }
    }

    static fromJS(data: any): GetScheduledJobsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetScheduledJobsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        if (Array.isArray(this.outputMessages)) {
            data["outputMessages"] = [];
            for (let item of this.outputMessages)
                data["outputMessages"].push(item);
        }
        return data; 
    }
}

export interface IGetScheduledJobsResponse {
    id?: string | undefined;
    name?: ScheduledJobName;
    state?: ScheduledJobState;
    outputMessages?: string[];
}

export enum ScheduledJobName {
    VersionRegionalLayoutImport = 0,
    CalculatingKmWaterways = 1,
}

export enum ScheduledJobState {
    Scheduled = 0,
    Started = 1,
    Succeed = 2,
    Failed = 3,
}

export class GetVersionRegionalLayoutImportResponse implements IGetVersionRegionalLayoutImportResponse {
    id?: string | undefined;
    state?: VersionRegionalLayoutImportState;
    startedBy?: string;
    startedAt?: Date;
    finishedAt?: Date | undefined;
    nextVersionRegionalLayoutName?: string;
    outputMessages?: string[];

    constructor(data?: IGetVersionRegionalLayoutImportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.startedBy = _data["startedBy"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
            this.nextVersionRegionalLayoutName = _data["nextVersionRegionalLayoutName"];
            if (Array.isArray(_data["outputMessages"])) {
                this.outputMessages = [] as any;
                for (let item of _data["outputMessages"])
                    this.outputMessages!.push(item);
            }
        }
    }

    static fromJS(data: any): GetVersionRegionalLayoutImportResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVersionRegionalLayoutImportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["startedBy"] = this.startedBy;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        data["nextVersionRegionalLayoutName"] = this.nextVersionRegionalLayoutName;
        if (Array.isArray(this.outputMessages)) {
            data["outputMessages"] = [];
            for (let item of this.outputMessages)
                data["outputMessages"].push(item);
        }
        return data; 
    }
}

export interface IGetVersionRegionalLayoutImportResponse {
    id?: string | undefined;
    state?: VersionRegionalLayoutImportState;
    startedBy?: string;
    startedAt?: Date;
    finishedAt?: Date | undefined;
    nextVersionRegionalLayoutName?: string;
    outputMessages?: string[];
}

export enum VersionRegionalLayoutImportState {
    Started = 0,
    Succeed = 1,
    Failed = 2,
}

export class VersionRegionalLayoutCreateResult implements IVersionRegionalLayoutCreateResult {
    succeed?: boolean;
    failed?: boolean;

    constructor(data?: IVersionRegionalLayoutCreateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeed = _data["succeed"];
            this.failed = _data["failed"];
        }
    }

    static fromJS(data: any): VersionRegionalLayoutCreateResult {
        data = typeof data === 'object' ? data : {};
        let result = new VersionRegionalLayoutCreateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeed"] = this.succeed;
        data["failed"] = this.failed;
        return data; 
    }
}

export interface IVersionRegionalLayoutCreateResult {
    succeed?: boolean;
    failed?: boolean;
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        this.errors![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["errors"][key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class ImportVersionRegionalLayout implements IImportVersionRegionalLayout {
    name?: string;
    file?: FileUpload;

    constructor(data?: IImportVersionRegionalLayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.file = _data["file"] ? FileUpload.fromJS(_data["file"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportVersionRegionalLayout {
        data = typeof data === 'object' ? data : {};
        let result = new ImportVersionRegionalLayout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IImportVersionRegionalLayout {
    name?: string;
    file?: FileUpload;
}

export class FileUpload implements IFileUpload {
    name?: string;
    size?: string;
    type?: string;
    lastModifiedTime?: number;
    lastModifiedDate?: Date;
    dataAsBase64?: string;
    dataAsByteArray?: string;

    constructor(data?: IFileUpload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.size = _data["size"];
            this.type = _data["type"];
            this.lastModifiedTime = _data["lastModifiedTime"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.dataAsBase64 = _data["dataAsBase64"];
            this.dataAsByteArray = _data["dataAsByteArray"];
        }
    }

    static fromJS(data: any): FileUpload {
        data = typeof data === 'object' ? data : {};
        let result = new FileUpload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["size"] = this.size;
        data["type"] = this.type;
        data["lastModifiedTime"] = this.lastModifiedTime;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["dataAsBase64"] = this.dataAsBase64;
        data["dataAsByteArray"] = this.dataAsByteArray;
        return data; 
    }
}

export interface IFileUpload {
    name?: string;
    size?: string;
    type?: string;
    lastModifiedTime?: number;
    lastModifiedDate?: Date;
    dataAsBase64?: string;
    dataAsByteArray?: string;
}

export class GetTimeRegistrationsOfWeekResponse implements IGetTimeRegistrationsOfWeekResponse {
    /** List of hours per day for the given week per user */
    daysOfWeek?: GetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate[];
    /** List of catches for the given week per user */
    catches?: GetTimeRegistrationsOfWeekResponseCatchItem[];
    /** List of general time registrations for the given week per user */
    timeRegistrationGeneralItems?: GetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral[];

    constructor(data?: IGetTimeRegistrationsOfWeekResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(GetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate.fromJS(item));
            }
            if (Array.isArray(_data["catches"])) {
                this.catches = [] as any;
                for (let item of _data["catches"])
                    this.catches!.push(GetTimeRegistrationsOfWeekResponseCatchItem.fromJS(item));
            }
            if (Array.isArray(_data["timeRegistrationGeneralItems"])) {
                this.timeRegistrationGeneralItems = [] as any;
                for (let item of _data["timeRegistrationGeneralItems"])
                    this.timeRegistrationGeneralItems!.push(GetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTimeRegistrationsOfWeekResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsOfWeekResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item.toJSON());
        }
        if (Array.isArray(this.catches)) {
            data["catches"] = [];
            for (let item of this.catches)
                data["catches"].push(item.toJSON());
        }
        if (Array.isArray(this.timeRegistrationGeneralItems)) {
            data["timeRegistrationGeneralItems"] = [];
            for (let item of this.timeRegistrationGeneralItems)
                data["timeRegistrationGeneralItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTimeRegistrationsOfWeekResponse {
    /** List of hours per day for the given week per user */
    daysOfWeek?: GetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate[];
    /** List of catches for the given week per user */
    catches?: GetTimeRegistrationsOfWeekResponseCatchItem[];
    /** List of general time registrations for the given week per user */
    timeRegistrationGeneralItems?: GetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral[];
}

export class GetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate implements IGetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate {
    /** Day for which time registrations are listed */
    date?: Date;
    timeRegistrations?: GetTimeRegistrationsOfWeekResponseTimeRegistration[];

    constructor(data?: IGetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            if (Array.isArray(_data["timeRegistrations"])) {
                this.timeRegistrations = [] as any;
                for (let item of _data["timeRegistrations"])
                    this.timeRegistrations!.push(GetTimeRegistrationsOfWeekResponseTimeRegistration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        if (Array.isArray(this.timeRegistrations)) {
            data["timeRegistrations"] = [];
            for (let item of this.timeRegistrations)
                data["timeRegistrations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTimeRegistrationsOfWeekResponseTimeRegistrationsOfDate {
    /** Day for which time registrations are listed */
    date?: Date;
    timeRegistrations?: GetTimeRegistrationsOfWeekResponseTimeRegistration[];
}

export class GetTimeRegistrationsOfWeekResponseTimeRegistration implements IGetTimeRegistrationsOfWeekResponseTimeRegistration {
    /** GUID of time registration */
    id?: string | undefined;
    /** Day for which time registration is entered */
    date?: Date;
    /** Catch Area where time is loged */
    catchArea?: NamedEntityItem;
    /** Sub Area where time is loged */
    subArea?: NamedEntityItem;
    /** Hour Square (Atlas Block) where time is loged */
    hourSquare?: NamedEntityItem;
    /** Trapping type the time is spent ton */
    trappingType?: NamedEntityItem;
    /** Amount of spent hours */
    hours?: number | undefined;
    /** Amount of spent minutes */
    minutes?: number | undefined;
    /** Status of the time registration entry: written, closed, completed */
    status?: TimeRegistrationStatus;

    constructor(data?: IGetTimeRegistrationsOfWeekResponseTimeRegistration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.catchArea = _data["catchArea"] ? NamedEntityItem.fromJS(_data["catchArea"]) : <any>undefined;
            this.subArea = _data["subArea"] ? NamedEntityItem.fromJS(_data["subArea"]) : <any>undefined;
            this.hourSquare = _data["hourSquare"] ? NamedEntityItem.fromJS(_data["hourSquare"]) : <any>undefined;
            this.trappingType = _data["trappingType"] ? NamedEntityItem.fromJS(_data["trappingType"]) : <any>undefined;
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationsOfWeekResponseTimeRegistration {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsOfWeekResponseTimeRegistration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["catchArea"] = this.catchArea ? this.catchArea.toJSON() : <any>undefined;
        data["subArea"] = this.subArea ? this.subArea.toJSON() : <any>undefined;
        data["hourSquare"] = this.hourSquare ? this.hourSquare.toJSON() : <any>undefined;
        data["trappingType"] = this.trappingType ? this.trappingType.toJSON() : <any>undefined;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        data["status"] = this.status;
        return data; 
    }
}

export interface IGetTimeRegistrationsOfWeekResponseTimeRegistration {
    /** GUID of time registration */
    id?: string | undefined;
    /** Day for which time registration is entered */
    date?: Date;
    /** Catch Area where time is loged */
    catchArea?: NamedEntityItem;
    /** Sub Area where time is loged */
    subArea?: NamedEntityItem;
    /** Hour Square (Atlas Block) where time is loged */
    hourSquare?: NamedEntityItem;
    /** Trapping type the time is spent ton */
    trappingType?: NamedEntityItem;
    /** Amount of spent hours */
    hours?: number | undefined;
    /** Amount of spent minutes */
    minutes?: number | undefined;
    /** Status of the time registration entry: written, closed, completed */
    status?: TimeRegistrationStatus;
}

export enum TimeRegistrationStatus {
    Written = 1,
    Closed = 2,
    Completed = 3,
}

export class GetTimeRegistrationsOfWeekResponseCatchItem implements IGetTimeRegistrationsOfWeekResponseCatchItem {
    /** GUID of the catch */
    id?: string;
    /** Date when the catch is stored in database */
    createdOn?: Date;
    /** Date when the catch is registered on mobile */
    recordedOn?: Date;
    /** Catch Area where catch is logged */
    catchArea?: NamedEntityItem;
    /** Sub Area where catch is logged */
    subArea?: NamedEntityItem;
    /** Hour Square (Atlas Block) where catch is logged */
    hourSquare?: NamedEntityItem;
    /** Guid of catch type of catch */
    catchTypeId?: string;
    /** Name of catch type of catch */
    catchType?: NamedEntityItem;
    /** Number of catches */
    number?: number;
    /** Status of catch: written, closed, completed */
    status?: CatchStatus;
    /** Indicator for catch or by-catch */
    isByCatch?: boolean;

    constructor(data?: IGetTimeRegistrationsOfWeekResponseCatchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.catchArea = _data["catchArea"] ? NamedEntityItem.fromJS(_data["catchArea"]) : <any>undefined;
            this.subArea = _data["subArea"] ? NamedEntityItem.fromJS(_data["subArea"]) : <any>undefined;
            this.hourSquare = _data["hourSquare"] ? NamedEntityItem.fromJS(_data["hourSquare"]) : <any>undefined;
            this.catchTypeId = _data["catchTypeId"];
            this.catchType = _data["catchType"] ? NamedEntityItem.fromJS(_data["catchType"]) : <any>undefined;
            this.number = _data["number"];
            this.status = _data["status"];
            this.isByCatch = _data["isByCatch"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationsOfWeekResponseCatchItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsOfWeekResponseCatchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["catchArea"] = this.catchArea ? this.catchArea.toJSON() : <any>undefined;
        data["subArea"] = this.subArea ? this.subArea.toJSON() : <any>undefined;
        data["hourSquare"] = this.hourSquare ? this.hourSquare.toJSON() : <any>undefined;
        data["catchTypeId"] = this.catchTypeId;
        data["catchType"] = this.catchType ? this.catchType.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["status"] = this.status;
        data["isByCatch"] = this.isByCatch;
        return data; 
    }
}

export interface IGetTimeRegistrationsOfWeekResponseCatchItem {
    /** GUID of the catch */
    id?: string;
    /** Date when the catch is stored in database */
    createdOn?: Date;
    /** Date when the catch is registered on mobile */
    recordedOn?: Date;
    /** Catch Area where catch is logged */
    catchArea?: NamedEntityItem;
    /** Sub Area where catch is logged */
    subArea?: NamedEntityItem;
    /** Hour Square (Atlas Block) where catch is logged */
    hourSquare?: NamedEntityItem;
    /** Guid of catch type of catch */
    catchTypeId?: string;
    /** Name of catch type of catch */
    catchType?: NamedEntityItem;
    /** Number of catches */
    number?: number;
    /** Status of catch: written, closed, completed */
    status?: CatchStatus;
    /** Indicator for catch or by-catch */
    isByCatch?: boolean;
}

export class GetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral implements IGetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral {
    /** GUID of the time registration general item */
    id?: string;
    /** Category of time registration general item */
    category?: NamedEntityItem;
    /** Date time registration general item was entered */
    date?: Date;
    /** Status of time registration general item: written, closed, completed */
    status?: TimeRegistrationStatus;
    /** Amount of spent hours */
    hours?: number;
    /** Amount of spent minutes */
    minutes?: number;

    constructor(data?: IGetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"] ? NamedEntityItem.fromJS(_data["category"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        return data; 
    }
}

export interface IGetTimeRegistrationsOfWeekResponseTimeRegistrationGeneral {
    /** GUID of the time registration general item */
    id?: string;
    /** Category of time registration general item */
    category?: NamedEntityItem;
    /** Date time registration general item was entered */
    date?: Date;
    /** Status of time registration general item: written, closed, completed */
    status?: TimeRegistrationStatus;
    /** Amount of spent hours */
    hours?: number;
    /** Amount of spent minutes */
    minutes?: number;
}

export class GetTimeRegistrationPerRayonResponse implements IGetTimeRegistrationPerRayonResponse {
    /** List of users who registered time in a rayon */
    usersWithRegisteredTimePerRayon?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon[];
    /** List of users who made time registration generals */
    usersWithTimeRegistrationGeneralItems?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser[];
    /** List of users in the organization rayon belongs to */
    usersInOrganization?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser[];

    constructor(data?: IGetTimeRegistrationPerRayonResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["usersWithRegisteredTimePerRayon"])) {
                this.usersWithRegisteredTimePerRayon = [] as any;
                for (let item of _data["usersWithRegisteredTimePerRayon"])
                    this.usersWithRegisteredTimePerRayon!.push(GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon.fromJS(item));
            }
            if (Array.isArray(_data["usersWithTimeRegistrationGeneralItems"])) {
                this.usersWithTimeRegistrationGeneralItems = [] as any;
                for (let item of _data["usersWithTimeRegistrationGeneralItems"])
                    this.usersWithTimeRegistrationGeneralItems!.push(GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser.fromJS(item));
            }
            if (Array.isArray(_data["usersInOrganization"])) {
                this.usersInOrganization = [] as any;
                for (let item of _data["usersInOrganization"])
                    this.usersInOrganization!.push(GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTimeRegistrationPerRayonResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationPerRayonResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.usersWithRegisteredTimePerRayon)) {
            data["usersWithRegisteredTimePerRayon"] = [];
            for (let item of this.usersWithRegisteredTimePerRayon)
                data["usersWithRegisteredTimePerRayon"].push(item.toJSON());
        }
        if (Array.isArray(this.usersWithTimeRegistrationGeneralItems)) {
            data["usersWithTimeRegistrationGeneralItems"] = [];
            for (let item of this.usersWithTimeRegistrationGeneralItems)
                data["usersWithTimeRegistrationGeneralItems"].push(item.toJSON());
        }
        if (Array.isArray(this.usersInOrganization)) {
            data["usersInOrganization"] = [];
            for (let item of this.usersInOrganization)
                data["usersInOrganization"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTimeRegistrationPerRayonResponse {
    /** List of users who registered time in a rayon */
    usersWithRegisteredTimePerRayon?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon[];
    /** List of users who made time registration generals */
    usersWithTimeRegistrationGeneralItems?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser[];
    /** List of users in the organization rayon belongs to */
    usersInOrganization?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser[];
}

export class GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon implements IGetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon {
    /** GUID of the rayon */
    rayonId?: string;
    /** Name of the Rayon */
    rayonName?: string | undefined;
    /** List of user in this rayon */
    users?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser[] | undefined;

    constructor(data?: IGetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rayonId = _data["rayonId"];
            this.rayonName = _data["rayonName"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rayonId"] = this.rayonId;
        data["rayonName"] = this.rayonName;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayon {
    /** GUID of the rayon */
    rayonId?: string;
    /** Name of the Rayon */
    rayonName?: string | undefined;
    /** List of user in this rayon */
    users?: GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser[] | undefined;
}

export class GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser implements IGetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser {
    /** GUID of user */
    id?: string;
    /** Fullname of user */
    name?: string | undefined;
    /** Indication whether user closed the week for time writing */
    weekCompleted?: boolean;
    /** Indication whether time can be entered for this week */
    weekActive?: boolean;

    constructor(data?: IGetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.weekCompleted = _data["weekCompleted"];
            this.weekActive = _data["weekActive"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["weekCompleted"] = this.weekCompleted;
        data["weekActive"] = this.weekActive;
        return data; 
    }
}

export interface IGetTimeRegistrationPerRayonResponseTimeRegistrationsPerRayonUser {
    /** GUID of user */
    id?: string;
    /** Fullname of user */
    name?: string | undefined;
    /** Indication whether user closed the week for time writing */
    weekCompleted?: boolean;
    /** Indication whether time can be entered for this week */
    weekActive?: boolean;
}

export class TimeRegistrationsEditCommand implements ITimeRegistrationsEditCommand {
    /** GUID of the Sub Area Hour Square where time is registered */
    subAreaHourSquareId?: string | undefined;
    /** First day of week this time registration applies to */
    startDate?: Date;
    /** Last day of week this time registration applies to */
    endDate?: Date;
    /** List of time registrations per day */
    daysOfWeek?: TimeRegistrationsEditCommandTimeRegistrationsOfDate[];
    /** List of catches in that week */
    catches?: TimeRegistrationsEditCatchItem[];
    /** List of general time registrations per day */
    timeRegistrationGeneralItems?: TimeRegistrationsEditTimeRegistrationGeneral[];

    constructor(data?: ITimeRegistrationsEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subAreaHourSquareId = _data["subAreaHourSquareId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(TimeRegistrationsEditCommandTimeRegistrationsOfDate.fromJS(item));
            }
            if (Array.isArray(_data["catches"])) {
                this.catches = [] as any;
                for (let item of _data["catches"])
                    this.catches!.push(TimeRegistrationsEditCatchItem.fromJS(item));
            }
            if (Array.isArray(_data["timeRegistrationGeneralItems"])) {
                this.timeRegistrationGeneralItems = [] as any;
                for (let item of _data["timeRegistrationGeneralItems"])
                    this.timeRegistrationGeneralItems!.push(TimeRegistrationsEditTimeRegistrationGeneral.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subAreaHourSquareId"] = this.subAreaHourSquareId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item.toJSON());
        }
        if (Array.isArray(this.catches)) {
            data["catches"] = [];
            for (let item of this.catches)
                data["catches"].push(item.toJSON());
        }
        if (Array.isArray(this.timeRegistrationGeneralItems)) {
            data["timeRegistrationGeneralItems"] = [];
            for (let item of this.timeRegistrationGeneralItems)
                data["timeRegistrationGeneralItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITimeRegistrationsEditCommand {
    /** GUID of the Sub Area Hour Square where time is registered */
    subAreaHourSquareId?: string | undefined;
    /** First day of week this time registration applies to */
    startDate?: Date;
    /** Last day of week this time registration applies to */
    endDate?: Date;
    /** List of time registrations per day */
    daysOfWeek?: TimeRegistrationsEditCommandTimeRegistrationsOfDate[];
    /** List of catches in that week */
    catches?: TimeRegistrationsEditCatchItem[];
    /** List of general time registrations per day */
    timeRegistrationGeneralItems?: TimeRegistrationsEditTimeRegistrationGeneral[];
}

export class TimeRegistrationsEditCommandTimeRegistrationsOfDate implements ITimeRegistrationsEditCommandTimeRegistrationsOfDate {
    /** Day this time registration applies to */
    date?: Date;
    /** List of time registratios for current day */
    items?: TimeRegistrationsEditCommandItem[] | undefined;

    constructor(data?: ITimeRegistrationsEditCommandTimeRegistrationsOfDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TimeRegistrationsEditCommandItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCommandTimeRegistrationsOfDate {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCommandTimeRegistrationsOfDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITimeRegistrationsEditCommandTimeRegistrationsOfDate {
    /** Day this time registration applies to */
    date?: Date;
    /** List of time registratios for current day */
    items?: TimeRegistrationsEditCommandItem[] | undefined;
}

export class TimeRegistrationsEditCommandItem implements ITimeRegistrationsEditCommandItem {
    /** GUID of this time registration */
    id?: string | undefined;
    /** Day this record applies to */
    date?: Date;
    /** Sub Area guid */
    subAreaId?: string;
    /** Hour Square guid */
    hourSquareId?: string;
    /** GUID of the trapping type the time applies to */
    trappingTypeId?: string;
    /** Amount of hours */
    hours?: number;
    /** Amount of minutes */
    minutes?: number;
    /** Status of this time registration record */
    status?: TimeRegistrationStatus;

    constructor(data?: ITimeRegistrationsEditCommandItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.subAreaId = _data["subAreaId"];
            this.hourSquareId = _data["hourSquareId"];
            this.trappingTypeId = _data["trappingTypeId"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCommandItem {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCommandItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["subAreaId"] = this.subAreaId;
        data["hourSquareId"] = this.hourSquareId;
        data["trappingTypeId"] = this.trappingTypeId;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        data["status"] = this.status;
        return data; 
    }
}

export interface ITimeRegistrationsEditCommandItem {
    /** GUID of this time registration */
    id?: string | undefined;
    /** Day this record applies to */
    date?: Date;
    /** Sub Area guid */
    subAreaId?: string;
    /** Hour Square guid */
    hourSquareId?: string;
    /** GUID of the trapping type the time applies to */
    trappingTypeId?: string;
    /** Amount of hours */
    hours?: number;
    /** Amount of minutes */
    minutes?: number;
    /** Status of this time registration record */
    status?: TimeRegistrationStatus;
}

export class TimeRegistrationsEditCatchItem implements ITimeRegistrationsEditCatchItem {
    /** GUID of the catch */
    id?: string;
    /** Created on */
    createdOn?: Date;
    /** Catch type guid for this catch */
    catchTypeId?: string;
    /** Number of catches */
    number?: number;
    /** Status of this catch */
    status?: CatchStatus;
    /** Indicator if this is catch or by-catch */
    isByCatch?: boolean;

    constructor(data?: ITimeRegistrationsEditCatchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.catchTypeId = _data["catchTypeId"];
            this.number = _data["number"];
            this.status = _data["status"];
            this.isByCatch = _data["isByCatch"];
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCatchItem {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCatchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["catchTypeId"] = this.catchTypeId;
        data["number"] = this.number;
        data["status"] = this.status;
        data["isByCatch"] = this.isByCatch;
        return data; 
    }
}

export interface ITimeRegistrationsEditCatchItem {
    /** GUID of the catch */
    id?: string;
    /** Created on */
    createdOn?: Date;
    /** Catch type guid for this catch */
    catchTypeId?: string;
    /** Number of catches */
    number?: number;
    /** Status of this catch */
    status?: CatchStatus;
    /** Indicator if this is catch or by-catch */
    isByCatch?: boolean;
}

export class TimeRegistrationsEditTimeRegistrationGeneral implements ITimeRegistrationsEditTimeRegistrationGeneral {
    id?: string | undefined;
    date?: Date;
    categoryId?: string;
    status?: TimeRegistrationStatus;
    hours?: number;
    minutes?: number;

    constructor(data?: ITimeRegistrationsEditTimeRegistrationGeneral) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.status = _data["status"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
        }
    }

    static fromJS(data: any): TimeRegistrationsEditTimeRegistrationGeneral {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditTimeRegistrationGeneral();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["status"] = this.status;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        return data; 
    }
}

export interface ITimeRegistrationsEditTimeRegistrationGeneral {
    id?: string | undefined;
    date?: Date;
    categoryId?: string;
    status?: TimeRegistrationStatus;
    hours?: number;
    minutes?: number;
}

export class PagedResponseOfGetTimeRegistrationCategoryResponse implements IPagedResponseOfGetTimeRegistrationCategoryResponse {
    items?: GetTimeRegistrationCategoryResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetTimeRegistrationCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTimeRegistrationCategoryResponse.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetTimeRegistrationCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetTimeRegistrationCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetTimeRegistrationCategoryResponse {
    items?: GetTimeRegistrationCategoryResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetTimeRegistrationCategoryResponse implements IGetTimeRegistrationCategoryResponse {
    /** GUID of the time registration category */
    id?: string;
    /** Name of the time registration category */
    name?: string;
    /** Indicator whether time registration category is active */
    active?: boolean;

    constructor(data?: IGetTimeRegistrationCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["active"] = this.active;
        return data; 
    }
}

export interface IGetTimeRegistrationCategoryResponse {
    /** GUID of the time registration category */
    id?: string;
    /** Name of the time registration category */
    name?: string;
    /** Indicator whether time registration category is active */
    active?: boolean;
}

export class TimeRegistrationCategoryCreateOrUpdateCommand implements ITimeRegistrationCategoryCreateOrUpdateCommand {
    /** GUID of the trap type */
    id?: string | undefined;
    /** Name of the trap type */
    name?: string;
    /** Indicator whether trap type is active */
    active?: boolean;

    constructor(data?: ITimeRegistrationCategoryCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): TimeRegistrationCategoryCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationCategoryCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["active"] = this.active;
        return data; 
    }
}

export interface ITimeRegistrationCategoryCreateOrUpdateCommand {
    /** GUID of the trap type */
    id?: string | undefined;
    /** Name of the trap type */
    name?: string;
    /** Indicator whether trap type is active */
    active?: boolean;
}

export class GetGeoServerSettingsResponse implements IGetGeoServerSettingsResponse {
    url?: string;
    accessKey?: string;
    backOfficeUser?: string;
    mobileUser?: string;

    constructor(data?: IGetGeoServerSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.accessKey = _data["accessKey"];
            this.backOfficeUser = _data["backOfficeUser"];
            this.mobileUser = _data["mobileUser"];
        }
    }

    static fromJS(data: any): GetGeoServerSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeoServerSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["accessKey"] = this.accessKey;
        data["backOfficeUser"] = this.backOfficeUser;
        data["mobileUser"] = this.mobileUser;
        return data; 
    }
}

export interface IGetGeoServerSettingsResponse {
    url?: string;
    accessKey?: string;
    backOfficeUser?: string;
    mobileUser?: string;
}

export class GetPredictionResponse implements IGetPredictionResponse {
    modelQuality?: number;
    prediction?: GetPredictionResponseItem | undefined;
    items?: GetPredictionResponseItem[];

    constructor(data?: IGetPredictionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelQuality = _data["modelQuality"];
            this.prediction = _data["prediction"] ? GetPredictionResponseItem.fromJS(_data["prediction"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPredictionResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPredictionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPredictionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelQuality"] = this.modelQuality;
        data["prediction"] = this.prediction ? this.prediction.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPredictionResponse {
    modelQuality?: number;
    prediction?: GetPredictionResponseItem | undefined;
    items?: GetPredictionResponseItem[];
}

export class GetPredictionResponseItem implements IGetPredictionResponseItem {
    summerCatches?: number | undefined;
    springCatches?: number | undefined;
    autumnCatches?: number | undefined;
    winterCatches?: number | undefined;
    summerHours?: number | undefined;
    springHours?: number | undefined;
    autumnHours?: number | undefined;
    winterHours?: number | undefined;
    year?: number;

    constructor(data?: IGetPredictionResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.summerCatches = _data["summerCatches"];
            this.springCatches = _data["springCatches"];
            this.autumnCatches = _data["autumnCatches"];
            this.winterCatches = _data["winterCatches"];
            this.summerHours = _data["summerHours"];
            this.springHours = _data["springHours"];
            this.autumnHours = _data["autumnHours"];
            this.winterHours = _data["winterHours"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): GetPredictionResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetPredictionResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summerCatches"] = this.summerCatches;
        data["springCatches"] = this.springCatches;
        data["autumnCatches"] = this.autumnCatches;
        data["winterCatches"] = this.winterCatches;
        data["summerHours"] = this.summerHours;
        data["springHours"] = this.springHours;
        data["autumnHours"] = this.autumnHours;
        data["winterHours"] = this.winterHours;
        data["year"] = this.year;
        return data; 
    }
}

export interface IGetPredictionResponseItem {
    summerCatches?: number | undefined;
    springCatches?: number | undefined;
    autumnCatches?: number | undefined;
    winterCatches?: number | undefined;
    summerHours?: number | undefined;
    springHours?: number | undefined;
    autumnHours?: number | undefined;
    winterHours?: number | undefined;
    year?: number;
}

export class GetReportTemplatesResponse implements IGetReportTemplatesResponse {
    items?: GetReportTemplatesResponseItem[];

    constructor(data?: IGetReportTemplatesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetReportTemplatesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReportTemplatesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplatesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetReportTemplatesResponse {
    items?: GetReportTemplatesResponseItem[];
}

export class GetReportTemplatesResponseItem implements IGetReportTemplatesResponseItem {
    /** GUID of the report template */
    id?: string;
    /** Name of the template */
    title?: string;
    /** Name of the report group (Vangstrapportage, Heatmap, Speurkaart) */
    group?: string;
    /** Endpoint route of the template */
    routeUri?: string;
    /** Report type (DevExtreme, Geo) */
    type?: ReportTemplateType;
    /** Key */
    key?: string;
    /** Name of the export file */
    exportFileName?: string;
    /** Content which is used to build the template */
    content?: string;
    /** Indicator whether template is active */
    active?: boolean;
    /** Indicator whether template is exported */
    exported?: boolean;
    /** Chart type selected */
    chartType?: ChartType;

    constructor(data?: IGetReportTemplatesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.group = _data["group"];
            this.routeUri = _data["routeUri"];
            this.type = _data["type"];
            this.key = _data["key"];
            this.exportFileName = _data["exportFileName"];
            this.content = _data["content"];
            this.active = _data["active"];
            this.exported = _data["exported"];
            this.chartType = _data["chartType"];
        }
    }

    static fromJS(data: any): GetReportTemplatesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplatesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["group"] = this.group;
        data["routeUri"] = this.routeUri;
        data["type"] = this.type;
        data["key"] = this.key;
        data["exportFileName"] = this.exportFileName;
        data["content"] = this.content;
        data["active"] = this.active;
        data["exported"] = this.exported;
        data["chartType"] = this.chartType;
        return data; 
    }
}

export interface IGetReportTemplatesResponseItem {
    /** GUID of the report template */
    id?: string;
    /** Name of the template */
    title?: string;
    /** Name of the report group (Vangstrapportage, Heatmap, Speurkaart) */
    group?: string;
    /** Endpoint route of the template */
    routeUri?: string;
    /** Report type (DevExtreme, Geo) */
    type?: ReportTemplateType;
    /** Key */
    key?: string;
    /** Name of the export file */
    exportFileName?: string;
    /** Content which is used to build the template */
    content?: string;
    /** Indicator whether template is active */
    active?: boolean;
    /** Indicator whether template is exported */
    exported?: boolean;
    /** Chart type selected */
    chartType?: ChartType;
}

export enum ReportTemplateType {
    DevExtreme = 1,
    GeoMap = 2,
    StandardReport = 3,
}

export enum ChartType {
    None = 0,
    Line = 1,
    Bar = 2,
    Scatter = 3,
}

export class GetReportTemplateResponse implements IGetReportTemplateResponse {
    item?: GetReportTemplatesResponseItem;

    constructor(data?: IGetReportTemplateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item = _data["item"] ? GetReportTemplatesResponseItem.fromJS(_data["item"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetReportTemplateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item"] = this.item ? this.item.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetReportTemplateResponse {
    item?: GetReportTemplatesResponseItem;
}

export class CreateReportTemplateExportResult implements ICreateReportTemplateExportResult {
    id?: string;

    constructor(data?: ICreateReportTemplateExportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateReportTemplateExportResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReportTemplateExportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateReportTemplateExportResult {
    id?: string;
}

export class CreateReportTemplateExportCommand implements ICreateReportTemplateExportCommand {
    /** Endpoint of the report */
    reportUri?: string;
    /** Name for this report template */
    templateTitle?: string;
    /** Content report is build of */
    templateContent?: string;
    /** Chart type selected */
    chartType?: ChartType;

    constructor(data?: ICreateReportTemplateExportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportUri = _data["reportUri"];
            this.templateTitle = _data["templateTitle"];
            this.templateContent = _data["templateContent"];
            this.chartType = _data["chartType"];
        }
    }

    static fromJS(data: any): CreateReportTemplateExportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReportTemplateExportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportUri"] = this.reportUri;
        data["templateTitle"] = this.templateTitle;
        data["templateContent"] = this.templateContent;
        data["chartType"] = this.chartType;
        return data; 
    }
}

export interface ICreateReportTemplateExportCommand {
    /** Endpoint of the report */
    reportUri?: string;
    /** Name for this report template */
    templateTitle?: string;
    /** Content report is build of */
    templateContent?: string;
    /** Chart type selected */
    chartType?: ChartType;
}

export class GetOrganizationsResponse implements IGetOrganizationsResponse {
    items?: GetOrganizationsResponseItem[];

    constructor(data?: IGetOrganizationsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOrganizationsResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetOrganizationsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetOrganizationsResponse {
    items?: GetOrganizationsResponseItem[];
}

export class GetOrganizationsResponseItem implements IGetOrganizationsResponseItem {
    /** GUID of the organization */
    id?: string;
    /** Name of the organization */
    name?: string;

    constructor(data?: IGetOrganizationsResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetOrganizationsResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationsResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetOrganizationsResponseItem {
    /** GUID of the organization */
    id?: string;
    /** Name of the organization */
    name?: string;
}

export class GetOrganizationsQuery implements IGetOrganizationsQuery {

    constructor(data?: IGetOrganizationsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetOrganizationsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetOrganizationsQuery {
}

export class GetObservationDetailsResponseItem implements IGetObservationDetailsResponseItem {
    /** GUID of the observation */
    id?: string;
    /** GUID of the user who created observation */
    createdBy?: string;
    /** Updated By */
    updatedBy?: string;
    /** Type of observation (schade, other) */
    type?: number;
    /** URL on blob storage where image is stored */
    photoUrl?: string;
    /** Remarks placed by trapper */
    remarks?: string;
    /** Created on */
    createdOn?: Date;
    /** Positon defined by names of Sub Area Hour Square, Rayon and Hour Square */
    position?: string;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Recorded on */
    recordedOn?: Date;
    /** Longitude of observation where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;

    constructor(data?: IGetObservationDetailsResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.type = _data["type"];
            this.photoUrl = _data["photoUrl"];
            this.remarks = _data["remarks"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.position = _data["position"];
            this.archived = _data["archived"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): GetObservationDetailsResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetObservationDetailsResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["type"] = this.type;
        data["photoUrl"] = this.photoUrl;
        data["remarks"] = this.remarks;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["archived"] = this.archived;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data; 
    }
}

export interface IGetObservationDetailsResponseItem {
    /** GUID of the observation */
    id?: string;
    /** GUID of the user who created observation */
    createdBy?: string;
    /** Updated By */
    updatedBy?: string;
    /** Type of observation (schade, other) */
    type?: number;
    /** URL on blob storage where image is stored */
    photoUrl?: string;
    /** Remarks placed by trapper */
    remarks?: string;
    /** Created on */
    createdOn?: Date;
    /** Positon defined by names of Sub Area Hour Square, Rayon and Hour Square */
    position?: string;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Recorded on */
    recordedOn?: Date;
    /** Longitude of observation where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
}

export class ObservationUpdateCommand implements IObservationUpdateCommand {
    /** GUID of the observation */
    id!: string;
    /** Observation type (schade, overig) */
    type?: ObservationType;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Remarks for this observation */
    remarks?: string | undefined;

    constructor(data?: IObservationUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.archived = _data["archived"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): ObservationUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["archived"] = this.archived;
        data["remarks"] = this.remarks;
        return data; 
    }
}

export interface IObservationUpdateCommand {
    /** GUID of the observation */
    id: string;
    /** Observation type (schade, overig) */
    type?: ObservationType;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Remarks for this observation */
    remarks?: string | undefined;
}

export enum ObservationType {
    Schade = 1,
    Overig = 2,
}

export class ListResponseOfGetOverlayLayersResponseItem implements IListResponseOfGetOverlayLayersResponseItem {
    items?: GetOverlayLayersResponseItem[];

    constructor(data?: IListResponseOfGetOverlayLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOverlayLayersResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetOverlayLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetOverlayLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetOverlayLayersResponseItem {
    items?: GetOverlayLayersResponseItem[];
}

export class GetOverlayLayersResponseItem implements IGetOverlayLayersResponseItem {
    /** Technical name of layer */
    name?: string;
    /** Full name */
    fullName?: string;
    /** Name on screen for this layer */
    displayName?: string;
    /** Category code */
    categoryCode?: OverlayLayerCategoryCode;
    /** Category name */
    categoryDisplayName?: string;
    /** Url where layer can be retrieved from */
    url?: string;
    /** Indicator for layers stacking on eachother */
    displayZIndex?: number;
    /** Color to be used for drawing layer */
    color?: string;
    /** Geometry name */
    geometryFieldName?: string;
    /** Strategy for showing layers on screen */
    lookupStrategy?: OverlayLayerLookupStrategy;
    /** Lookup codes to be used for different maps */
    defaultMapStyle?: MapStyleLookupKeyCode;
    /** How long items should be cached */
    cacheSettings?: OverlayLayerCacheSettings;
    /** Width on screen for this layer */
    width?: number;
    /** Indicator whether it is used on backoffice, mobile or both */
    platformType?: OverlayLayerPlatformType;
    /** Overlay type (wms, wfs, wmts) */
    type?: OverlayLayerType;

    constructor(data?: IGetOverlayLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fullName = _data["fullName"];
            this.displayName = _data["displayName"];
            this.categoryCode = _data["categoryCode"];
            this.categoryDisplayName = _data["categoryDisplayName"];
            this.url = _data["url"];
            this.displayZIndex = _data["displayZIndex"];
            this.color = _data["color"];
            this.geometryFieldName = _data["geometryFieldName"];
            this.lookupStrategy = _data["lookupStrategy"];
            this.defaultMapStyle = _data["defaultMapStyle"] ? MapStyleLookupKeyCode.fromJS(_data["defaultMapStyle"]) : <any>undefined;
            this.cacheSettings = _data["cacheSettings"] ? OverlayLayerCacheSettings.fromJS(_data["cacheSettings"]) : <any>undefined;
            this.width = _data["width"];
            this.platformType = _data["platformType"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GetOverlayLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetOverlayLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["displayName"] = this.displayName;
        data["categoryCode"] = this.categoryCode;
        data["categoryDisplayName"] = this.categoryDisplayName;
        data["url"] = this.url;
        data["displayZIndex"] = this.displayZIndex;
        data["color"] = this.color;
        data["geometryFieldName"] = this.geometryFieldName;
        data["lookupStrategy"] = this.lookupStrategy;
        data["defaultMapStyle"] = this.defaultMapStyle ? this.defaultMapStyle.toJSON() : <any>undefined;
        data["cacheSettings"] = this.cacheSettings ? this.cacheSettings.toJSON() : <any>undefined;
        data["width"] = this.width;
        data["platformType"] = this.platformType;
        data["type"] = this.type;
        return data; 
    }
}

export interface IGetOverlayLayersResponseItem {
    /** Technical name of layer */
    name?: string;
    /** Full name */
    fullName?: string;
    /** Name on screen for this layer */
    displayName?: string;
    /** Category code */
    categoryCode?: OverlayLayerCategoryCode;
    /** Category name */
    categoryDisplayName?: string;
    /** Url where layer can be retrieved from */
    url?: string;
    /** Indicator for layers stacking on eachother */
    displayZIndex?: number;
    /** Color to be used for drawing layer */
    color?: string;
    /** Geometry name */
    geometryFieldName?: string;
    /** Strategy for showing layers on screen */
    lookupStrategy?: OverlayLayerLookupStrategy;
    /** Lookup codes to be used for different maps */
    defaultMapStyle?: MapStyleLookupKeyCode;
    /** How long items should be cached */
    cacheSettings?: OverlayLayerCacheSettings;
    /** Width on screen for this layer */
    width?: number;
    /** Indicator whether it is used on backoffice, mobile or both */
    platformType?: OverlayLayerPlatformType;
    /** Overlay type (wms, wfs, wmts) */
    type?: OverlayLayerType;
}

export enum OverlayLayerCategoryCode {
    MapAreas = 0,
    MapLocations = 1,
    ReportTracking = 2,
    ReportGeoRegionCatches = 3,
    HeatMapOfCatches = 4,
    DefaultLayers = 5,
}

export enum OverlayLayerLookupStrategy {
    All = 0,
    BBox = 1,
    Tracking = 2,
}

export class MapStyleLookupKeyCode implements IMapStyleLookupKeyCode {
    code?: string;

    constructor(data?: IMapStyleLookupKeyCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): MapStyleLookupKeyCode {
        data = typeof data === 'object' ? data : {};
        let result = new MapStyleLookupKeyCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IMapStyleLookupKeyCode {
    code?: string;
}

export class OverlayLayerCacheSettings implements IOverlayLayerCacheSettings {
    cacheStrategy?: OverlayLayerCacheStrategy;
    durationSeconds?: number;

    constructor(data?: IOverlayLayerCacheSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cacheStrategy = _data["cacheStrategy"];
            this.durationSeconds = _data["durationSeconds"];
        }
    }

    static fromJS(data: any): OverlayLayerCacheSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OverlayLayerCacheSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheStrategy"] = this.cacheStrategy;
        data["durationSeconds"] = this.durationSeconds;
        return data; 
    }
}

export interface IOverlayLayerCacheSettings {
    cacheStrategy?: OverlayLayerCacheStrategy;
    durationSeconds?: number;
}

export enum OverlayLayerCacheStrategy {
    NoCache = 0,
    CacheFirst = 1,
    NetworkFirst = 2,
}

export enum OverlayLayerPlatformType {
    All = 0,
    BackofficeOnly = 1,
    MobileOnly = 2,
}

export enum OverlayLayerType {
    Wms = 1,
    Wfs = 2,
    Wmts = 3,
}

export class ListResponseOfGetBackgroundLayersResponseItem implements IListResponseOfGetBackgroundLayersResponseItem {
    items?: GetBackgroundLayersResponseItem[];

    constructor(data?: IListResponseOfGetBackgroundLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBackgroundLayersResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetBackgroundLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetBackgroundLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetBackgroundLayersResponseItem {
    items?: GetBackgroundLayersResponseItem[];
}

export class GetBackgroundLayersResponseItem implements IGetBackgroundLayersResponseItem {
    /** Id of the layer */
    id?: string;
    /** Name of the layer */
    name?: string;
    /** URL where background layer is retrieved from */
    url?: string;
    /** Service type (wmts, mvt) */
    serviceType?: MapServiceType;
    /** Network type online of offline */
    networkType?: MapNetworkType;
    /** Overlay type (wms, wfs, wmts) */
    defaultOverlayLayer?: string | undefined;

    constructor(data?: IGetBackgroundLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.serviceType = _data["serviceType"];
            this.networkType = _data["networkType"];
            this.defaultOverlayLayer = _data["defaultOverlayLayer"];
        }
    }

    static fromJS(data: any): GetBackgroundLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetBackgroundLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        data["serviceType"] = this.serviceType;
        data["networkType"] = this.networkType;
        data["defaultOverlayLayer"] = this.defaultOverlayLayer;
        return data; 
    }
}

export interface IGetBackgroundLayersResponseItem {
    /** Id of the layer */
    id?: string;
    /** Name of the layer */
    name?: string;
    /** URL where background layer is retrieved from */
    url?: string;
    /** Service type (wmts, mvt) */
    serviceType?: MapServiceType;
    /** Network type online of offline */
    networkType?: MapNetworkType;
    /** Overlay type (wms, wfs, wmts) */
    defaultOverlayLayer?: string | undefined;
}

export enum MapServiceType {
    Wmts = 1,
    Mvt = 2,
}

export enum MapNetworkType {
    Online = 1,
    Offline = 2,
}

export class GetBackgroundLayersQuery implements IGetBackgroundLayersQuery {

    constructor(data?: IGetBackgroundLayersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetBackgroundLayersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetBackgroundLayersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetBackgroundLayersQuery {
}

export class GetMapStylesResponse implements IGetMapStylesResponse {
    /** List of map styles */
    items?: MapStyleLookup[];

    constructor(data?: IGetMapStylesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MapStyleLookup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMapStylesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMapStylesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMapStylesResponse {
    /** List of map styles */
    items?: MapStyleLookup[];
}

export class MapStyleLookup implements IMapStyleLookup {
    /** key identifier */
    key?: MapStyleLookupKey;
    /** Icon that should be used for this style */
    iconName?: string;

    constructor(data?: IMapStyleLookup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] ? MapStyleLookupKey.fromJS(_data["key"]) : <any>undefined;
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): MapStyleLookup {
        data = typeof data === 'object' ? data : {};
        let result = new MapStyleLookup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["iconName"] = this.iconName;
        return data; 
    }
}

export interface IMapStyleLookup {
    /** key identifier */
    key?: MapStyleLookupKey;
    /** Icon that should be used for this style */
    iconName?: string;
}

export class MapStyleLookupKey implements IMapStyleLookupKey {
    lookupKeyCode?: MapStyleLookupKeyCode;
    trapTypeId?: string | undefined;
    trapStatus?: TrapStatus | undefined;

    constructor(data?: IMapStyleLookupKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupKeyCode = _data["lookupKeyCode"] ? MapStyleLookupKeyCode.fromJS(_data["lookupKeyCode"]) : <any>undefined;
            this.trapTypeId = _data["trapTypeId"];
            this.trapStatus = _data["trapStatus"];
        }
    }

    static fromJS(data: any): MapStyleLookupKey {
        data = typeof data === 'object' ? data : {};
        let result = new MapStyleLookupKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupKeyCode"] = this.lookupKeyCode ? this.lookupKeyCode.toJSON() : <any>undefined;
        data["trapTypeId"] = this.trapTypeId;
        data["trapStatus"] = this.trapStatus;
        return data; 
    }
}

export interface IMapStyleLookupKey {
    lookupKeyCode?: MapStyleLookupKeyCode;
    trapTypeId?: string | undefined;
    trapStatus?: TrapStatus | undefined;
}

export class ListResponseOfGetTrappingTypesResponseItem implements IListResponseOfGetTrappingTypesResponseItem {
    items?: GetTrappingTypesResponseItem[];

    constructor(data?: IListResponseOfGetTrappingTypesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrappingTypesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetTrappingTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetTrappingTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetTrappingTypesResponseItem {
    items?: GetTrappingTypesResponseItem[];
}

export class GetTrappingTypesResponseItem extends NamedEntityItem implements IGetTrappingTypesResponseItem {

    constructor(data?: IGetTrappingTypesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): GetTrappingTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrappingTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetTrappingTypesResponseItem extends INamedEntityItem {
}

export class ListResponseOfGetTrapTypesResponseItem implements IListResponseOfGetTrapTypesResponseItem {
    items?: GetTrapTypesResponseItem[];

    constructor(data?: IListResponseOfGetTrapTypesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrapTypesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetTrapTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetTrapTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetTrapTypesResponseItem {
    items?: GetTrapTypesResponseItem[];
}

export class GetTrapTypesResponseItem extends NamedEntityItem implements IGetTrapTypesResponseItem {
    trappingTypeId?: string;
    allowedStatuses?: TrapStatus[];

    constructor(data?: IGetTrapTypesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.trappingTypeId = _data["trappingTypeId"];
            if (Array.isArray(_data["allowedStatuses"])) {
                this.allowedStatuses = [] as any;
                for (let item of _data["allowedStatuses"])
                    this.allowedStatuses!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTrapTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trappingTypeId"] = this.trappingTypeId;
        if (Array.isArray(this.allowedStatuses)) {
            data["allowedStatuses"] = [];
            for (let item of this.allowedStatuses)
                data["allowedStatuses"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IGetTrapTypesResponseItem extends INamedEntityItem {
    trappingTypeId?: string;
    allowedStatuses?: TrapStatus[];
}

export class GetTrapTypesQuery implements IGetTrapTypesQuery {

    constructor(data?: IGetTrapTypesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetTrapTypesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapTypesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetTrapTypesQuery {
}

export class ListResponseOfGetCatchTypesResponseItem implements IListResponseOfGetCatchTypesResponseItem {
    items?: GetCatchTypesResponseItem[];

    constructor(data?: IListResponseOfGetCatchTypesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCatchTypesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetCatchTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetCatchTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetCatchTypesResponseItem {
    items?: GetCatchTypesResponseItem[];
}

export class GetCatchTypesResponseItem extends NamedEntityItem implements IGetCatchTypesResponseItem {
    /** Is this catch type used for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order to be used in listing on mobile */
    order?: number;

    constructor(data?: IGetCatchTypesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isByCatch = _data["isByCatch"];
            this.animalType = _data["animalType"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): GetCatchTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isByCatch"] = this.isByCatch;
        data["animalType"] = this.animalType;
        data["order"] = this.order;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetCatchTypesResponseItem extends INamedEntityItem {
    /** Is this catch type used for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order to be used in listing on mobile */
    order?: number;
}

export enum AnimalType {
    Mammal = 1,
    Bird = 2,
    Fish = 3,
    Other = 4,
}

export class GetCatchTypesQuery implements IGetCatchTypesQuery {

    constructor(data?: IGetCatchTypesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetCatchTypesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchTypesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetCatchTypesQuery {
}

export class ListResponseOfGetTimeRegistrationCategoriesResponseItem implements IListResponseOfGetTimeRegistrationCategoriesResponseItem {
    items?: GetTimeRegistrationCategoriesResponseItem[];

    constructor(data?: IListResponseOfGetTimeRegistrationCategoriesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTimeRegistrationCategoriesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetTimeRegistrationCategoriesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetTimeRegistrationCategoriesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetTimeRegistrationCategoriesResponseItem {
    items?: GetTimeRegistrationCategoriesResponseItem[];
}

export class GetTimeRegistrationCategoriesResponseItem extends NamedEntityItem implements IGetTimeRegistrationCategoriesResponseItem {
    active?: boolean;

    constructor(data?: IGetTimeRegistrationCategoriesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationCategoriesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationCategoriesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetTimeRegistrationCategoriesResponseItem extends INamedEntityItem {
    active?: boolean;
}

export class PagedResponseOfGetFieldTestResponse implements IPagedResponseOfGetFieldTestResponse {
    items?: GetFieldTestResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetFieldTestResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetFieldTestResponse.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetFieldTestResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetFieldTestResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetFieldTestResponse {
    items?: GetFieldTestResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetFieldTestResponse implements IGetFieldTestResponse {
    /** GUID of field test */
    id?: string;
    /** Name of the field test */
    name?: string;
    /** Begin date of field test */
    startPeriod?: string;
    /** End date of field test */
    endPeriod?: string;
    /** List of hour squares (atlas blocks) incorporated in field test */
    hourSquares?: GetFieldTestResponseHourSquare[];

    constructor(data?: IGetFieldTestResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startPeriod = _data["startPeriod"];
            this.endPeriod = _data["endPeriod"];
            if (Array.isArray(_data["hourSquares"])) {
                this.hourSquares = [] as any;
                for (let item of _data["hourSquares"])
                    this.hourSquares!.push(GetFieldTestResponseHourSquare.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFieldTestResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFieldTestResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startPeriod"] = this.startPeriod;
        data["endPeriod"] = this.endPeriod;
        if (Array.isArray(this.hourSquares)) {
            data["hourSquares"] = [];
            for (let item of this.hourSquares)
                data["hourSquares"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetFieldTestResponse {
    /** GUID of field test */
    id?: string;
    /** Name of the field test */
    name?: string;
    /** Begin date of field test */
    startPeriod?: string;
    /** End date of field test */
    endPeriod?: string;
    /** List of hour squares (atlas blocks) incorporated in field test */
    hourSquares?: GetFieldTestResponseHourSquare[];
}

export class GetFieldTestResponseHourSquare implements IGetFieldTestResponseHourSquare {
    /** GUID of hour square (atlas block) */
    id?: string;
    /** Name of hour square (atlas block) */
    name?: string;

    constructor(data?: IGetFieldTestResponseHourSquare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetFieldTestResponseHourSquare {
        data = typeof data === 'object' ? data : {};
        let result = new GetFieldTestResponseHourSquare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetFieldTestResponseHourSquare {
    /** GUID of hour square (atlas block) */
    id?: string;
    /** Name of hour square (atlas block) */
    name?: string;
}

export class FieldTestCreateOrUpdateCommand implements IFieldTestCreateOrUpdateCommand {
    id!: string;
    name?: string;
    startPeriod?: string;
    endPeriod?: string;
    hourSquareIds?: string[];

    constructor(data?: IFieldTestCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startPeriod = _data["startPeriod"];
            this.endPeriod = _data["endPeriod"];
            if (Array.isArray(_data["hourSquareIds"])) {
                this.hourSquareIds = [] as any;
                for (let item of _data["hourSquareIds"])
                    this.hourSquareIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FieldTestCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FieldTestCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startPeriod"] = this.startPeriod;
        data["endPeriod"] = this.endPeriod;
        if (Array.isArray(this.hourSquareIds)) {
            data["hourSquareIds"] = [];
            for (let item of this.hourSquareIds)
                data["hourSquareIds"].push(item);
        }
        return data; 
    }
}

export interface IFieldTestCreateOrUpdateCommand {
    id: string;
    name?: string;
    startPeriod?: string;
    endPeriod?: string;
    hourSquareIds?: string[];
}

export class PagedResponseOfGetCatchTypeResponse implements IPagedResponseOfGetCatchTypeResponse {
    items?: GetCatchTypeResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetCatchTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCatchTypeResponse.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetCatchTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetCatchTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetCatchTypeResponse {
    items?: GetCatchTypeResponse[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetCatchTypeResponse implements IGetCatchTypeResponse {
    /** GUID of catch type */
    id?: string;
    /** name of catchtype */
    name?: string;
    /** Indicator of the catch type is for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order used for showing catch type on mobile */
    order?: number;

    constructor(data?: IGetCatchTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isByCatch = _data["isByCatch"];
            this.animalType = _data["animalType"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): GetCatchTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isByCatch"] = this.isByCatch;
        data["animalType"] = this.animalType;
        data["order"] = this.order;
        return data; 
    }
}

export interface IGetCatchTypeResponse {
    /** GUID of catch type */
    id?: string;
    /** name of catchtype */
    name?: string;
    /** Indicator of the catch type is for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order used for showing catch type on mobile */
    order?: number;
}

export class CatchTypeCreateOrUpdateCommand implements ICatchTypeCreateOrUpdateCommand {
    /** GUID of the catch type */
    id?: string | undefined;
    /** Name of catch type */
    name?: string;
    /** Is this catch type used for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order to be used in listing on mobile */
    order?: number;

    constructor(data?: ICatchTypeCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isByCatch = _data["isByCatch"];
            this.animalType = _data["animalType"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CatchTypeCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatchTypeCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isByCatch"] = this.isByCatch;
        data["animalType"] = this.animalType;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICatchTypeCreateOrUpdateCommand {
    /** GUID of the catch type */
    id?: string | undefined;
    /** Name of catch type */
    name?: string;
    /** Is this catch type used for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order to be used in listing on mobile */
    order?: number;
}

export class CatchCreateOrUpdateCommand implements ICatchCreateOrUpdateCommand {
    /** GUID of the catch */
    id!: string;
    /** Recorded on */
    recordedOn!: Date;
    /** Number of catches */
    number!: number;
    /** Catch status */
    status!: CatchStatus;
    /** GUID of the trap the catch is registered on */
    trapId!: string;
    /** GUID of the catch type */
    catchTypeId!: string;
    /** When set to true, the catch will be removed from database  */
    markedForRemoval!: boolean;

    constructor(data?: ICatchCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.status = _data["status"];
            this.trapId = _data["trapId"];
            this.catchTypeId = _data["catchTypeId"];
            this.markedForRemoval = _data["markedForRemoval"];
        }
    }

    static fromJS(data: any): CatchCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatchCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["status"] = this.status;
        data["trapId"] = this.trapId;
        data["catchTypeId"] = this.catchTypeId;
        data["markedForRemoval"] = this.markedForRemoval;
        return data; 
    }
}

export interface ICatchCreateOrUpdateCommand {
    /** GUID of the catch */
    id: string;
    /** Recorded on */
    recordedOn: Date;
    /** Number of catches */
    number: number;
    /** Catch status */
    status: CatchStatus;
    /** GUID of the trap the catch is registered on */
    trapId: string;
    /** GUID of the catch type */
    catchTypeId: string;
    /** When set to true, the catch will be removed from database  */
    markedForRemoval: boolean;
}

export class GetAreaEntitiesResponse implements IGetAreaEntitiesResponse {
    items?: NamedEntityItem[];

    constructor(data?: IGetAreaEntitiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NamedEntityItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAreaEntitiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAreaEntitiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAreaEntitiesResponse {
    items?: NamedEntityItem[];
}

export class GetCurrentUserProfileResponse implements IGetCurrentUserProfileResponse {
    /** GUID of the user */
    id?: string;
    /** Full name from the user
             */
    name?: string;
    /** Email that serves as UPN (User Prinicapal Name) for Azure AD account */
    email?: string;
    /** Indication whether user is granted access (true or false) */
    authorized?: boolean;
    /** Indication if the user complied with the regulations policies for using trAPP */
    confidentialityConfirmed?: boolean;
    /** Set of rights a user has with the assigned roles to do in trAPP */
    policies?: string[];
    /** Organization to which user belongs */
    organizationId?: string | undefined;

    constructor(data?: IGetCurrentUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.authorized = _data["authorized"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
            if (Array.isArray(_data["policies"])) {
                this.policies = [] as any;
                for (let item of _data["policies"])
                    this.policies!.push(item);
            }
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): GetCurrentUserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentUserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["authorized"] = this.authorized;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        if (Array.isArray(this.policies)) {
            data["policies"] = [];
            for (let item of this.policies)
                data["policies"].push(item);
        }
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IGetCurrentUserProfileResponse {
    /** GUID of the user */
    id?: string;
    /** Full name from the user
             */
    name?: string;
    /** Email that serves as UPN (User Prinicapal Name) for Azure AD account */
    email?: string;
    /** Indication whether user is granted access (true or false) */
    authorized?: boolean;
    /** Indication if the user complied with the regulations policies for using trAPP */
    confidentialityConfirmed?: boolean;
    /** Set of rights a user has with the assigned roles to do in trAPP */
    policies?: string[];
    /** Organization to which user belongs */
    organizationId?: string | undefined;
}

export class AutoCreateUserAfterLoginResult implements IAutoCreateUserAfterLoginResult {
    /** New GUID created for the user */
    userId?: string;
    /** Indication whether creation of user was successfull */
    created?: boolean;

    constructor(data?: IAutoCreateUserAfterLoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.created = _data["created"];
        }
    }

    static fromJS(data: any): AutoCreateUserAfterLoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new AutoCreateUserAfterLoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["created"] = this.created;
        return data; 
    }
}

export interface IAutoCreateUserAfterLoginResult {
    /** New GUID created for the user */
    userId?: string;
    /** Indication whether creation of user was successfull */
    created?: boolean;
}

export class UserSessionTerminateResult implements IUserSessionTerminateResult {
    userEmail?: string;

    constructor(data?: IUserSessionTerminateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): UserSessionTerminateResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSessionTerminateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail;
        return data; 
    }
}

export interface IUserSessionTerminateResult {
    userEmail?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}