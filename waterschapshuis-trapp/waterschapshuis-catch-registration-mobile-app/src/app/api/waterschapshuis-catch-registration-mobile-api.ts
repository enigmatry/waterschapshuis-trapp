/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IUsersClient {
    /**
     * Get user for given id
     * @param id Id
     */
    get(id: string): Observable<GetUserDetailsResponse>;
    /**
     * Updates confidentiality property
     * @param command User data about confidentiality confirmation
     */
    updateConfidentiality(command: UserUpdateConfidentialityCommand): Observable<GetUserDetailsResponse>;
}

@Injectable()
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Get user for given id
     * @param id Id
     */
    get(id: string): Observable<GetUserDetailsResponse> {
        let url_ = this.baseUrl + "/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetUserDetailsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDetailsResponse>(<any>null);
    }

    /**
     * Updates confidentiality property
     * @param command User data about confidentiality confirmation
     */
    updateConfidentiality(command: UserUpdateConfidentialityCommand): Observable<GetUserDetailsResponse> {
        let url_ = this.baseUrl + "/v1/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConfidentiality(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfidentiality(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfidentiality(response: HttpResponseBase): Observable<GetUserDetailsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDetailsResponse>(<any>null);
    }
}

export interface ITrapsClient {
    /**
     * Get trap details for given id
     * @param id Id
     */
    get(id: string): Observable<GetTrapDetailsTrapItem>;
    /**
     * Physically delete trap
     * @param id Trap id
     */
    delete(id: string): Observable<boolean>;
    /**
     * Get trap details for multiple given trap ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetTrapDetailsTrapItem[]>;
    /**
     * Creates or updates a trap
     * @param command Trap data
     */
    post(command: TrapCreateOrUpdateCommand): Observable<GetTrapDetailsTrapItem>;
    /**
     * Get trap details within bounding box
     * @param locationLatitude (optional) 
     * @param locationLongitude (optional) 
     * @param widthKilometers (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     */
    getTraps(locationLatitude: number | null | undefined, locationLongitude: number | null | undefined, widthKilometers: number | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTrapDetailsTrapItem>;
    /**
     * Get current user Traps summary
     * @param includeDetails (optional) 
     */
    getCurrentUserSummary(includeDetails: boolean | undefined): Observable<GetMySummaryResponse>;
    /**
     * Get paged trap history entries
     * @param trapId (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     */
    getHistories(trapId: string | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTrapHistoriesHistoryItem>;
}

@Injectable()
export class TrapsClient implements ITrapsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Get trap details for given id
     * @param id Id
     */
    get(id: string): Observable<GetTrapDetailsTrapItem> {
        let url_ = this.baseUrl + "/v1/Traps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetTrapDetailsTrapItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTrapDetailsTrapItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapDetailsTrapItem>(<any>null);
    }

    /**
     * Physically delete trap
     * @param id Trap id
     */
    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/v1/Traps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Get trap details for multiple given trap ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetTrapDetailsTrapItem[]> {
        let url_ = this.baseUrl + "/v1/Traps?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultiple(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapDetailsTrapItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapDetailsTrapItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMultiple(response: HttpResponseBase): Observable<GetTrapDetailsTrapItem[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTrapDetailsTrapItem.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapDetailsTrapItem[]>(<any>null);
    }

    /**
     * Creates or updates a trap
     * @param command Trap data
     */
    post(command: TrapCreateOrUpdateCommand): Observable<GetTrapDetailsTrapItem> {
        let url_ = this.baseUrl + "/v1/Traps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTrapDetailsTrapItem>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetTrapDetailsTrapItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTrapDetailsTrapItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTrapDetailsTrapItem>(<any>null);
    }

    /**
     * Get trap details within bounding box
     * @param locationLatitude (optional) 
     * @param locationLongitude (optional) 
     * @param widthKilometers (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     */
    getTraps(locationLatitude: number | null | undefined, locationLongitude: number | null | undefined, widthKilometers: number | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTrapDetailsTrapItem> {
        let url_ = this.baseUrl + "/v1/Traps/get-traps?";
        if (locationLatitude !== undefined)
            url_ += "LocationLatitude=" + encodeURIComponent("" + locationLatitude) + "&"; 
        if (locationLongitude !== undefined)
            url_ += "LocationLongitude=" + encodeURIComponent("" + locationLongitude) + "&"; 
        if (widthKilometers === null)
            throw new Error("The parameter 'widthKilometers' cannot be null.");
        else if (widthKilometers !== undefined)
            url_ += "WidthKilometers=" + encodeURIComponent("" + widthKilometers) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTraps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTraps(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetTrapDetailsTrapItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetTrapDetailsTrapItem>><any>_observableThrow(response_);
        }));
    }

    protected processGetTraps(response: HttpResponseBase): Observable<PagedResponseOfGetTrapDetailsTrapItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetTrapDetailsTrapItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetTrapDetailsTrapItem>(<any>null);
    }

    /**
     * Get current user Traps summary
     * @param includeDetails (optional) 
     */
    getCurrentUserSummary(includeDetails: boolean | undefined): Observable<GetMySummaryResponse> {
        let url_ = this.baseUrl + "/v1/Traps/my-summary?";
        if (includeDetails === null)
            throw new Error("The parameter 'includeDetails' cannot be null.");
        else if (includeDetails !== undefined)
            url_ += "IncludeDetails=" + encodeURIComponent("" + includeDetails) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetMySummaryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMySummaryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserSummary(response: HttpResponseBase): Observable<GetMySummaryResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMySummaryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMySummaryResponse>(<any>null);
    }

    /**
     * Get paged trap history entries
     * @param trapId (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     */
    getHistories(trapId: string | undefined, sortField: string | null | undefined, sortDirection: string | null | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetTrapHistoriesHistoryItem> {
        let url_ = this.baseUrl + "/v1/Traps/histories?";
        if (trapId === null)
            throw new Error("The parameter 'trapId' cannot be null.");
        else if (trapId !== undefined)
            url_ += "TrapId=" + encodeURIComponent("" + trapId) + "&"; 
        if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&"; 
        if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetTrapHistoriesHistoryItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetTrapHistoriesHistoryItem>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistories(response: HttpResponseBase): Observable<PagedResponseOfGetTrapHistoriesHistoryItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetTrapHistoriesHistoryItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetTrapHistoriesHistoryItem>(<any>null);
    }
}

export interface ITimeRegistrationsClient {
    /**
     * Get time registrations for the current user for the requested date in optional SubAreaHourSquare
     * @param date (optional) The date of the requested time registrations
     * @param subAreaHourSquareId (optional) The Id of the SubAreaHourSquare for which to get time registration
     */
    get(date: Date | undefined, subAreaHourSquareId: string | null | undefined): Observable<GetTimeRegistrationsResponse>;
    /**
     * Creates, updates or deletes TimeRegistration data
     * @param command TimeRegistration data for update
     */
    post(command: TimeRegistrationsEditCommand): Observable<GetTimeRegistrationsResponse>;
}

@Injectable()
export class TimeRegistrationsClient implements ITimeRegistrationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Get time registrations for the current user for the requested date in optional SubAreaHourSquare
     * @param date (optional) The date of the requested time registrations
     * @param subAreaHourSquareId (optional) The Id of the SubAreaHourSquare for which to get time registration
     */
    get(date: Date | undefined, subAreaHourSquareId: string | null | undefined): Observable<GetTimeRegistrationsResponse> {
        let url_ = this.baseUrl + "/v1/TimeRegistrations?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        if (subAreaHourSquareId !== undefined)
            url_ += "subAreaHourSquareId=" + encodeURIComponent("" + subAreaHourSquareId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetTimeRegistrationsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationsResponse>(<any>null);
    }

    /**
     * Creates, updates or deletes TimeRegistration data
     * @param command TimeRegistration data for update
     */
    post(command: TimeRegistrationsEditCommand): Observable<GetTimeRegistrationsResponse> {
        let url_ = this.baseUrl + "/v1/TimeRegistrations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<GetTimeRegistrationsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTimeRegistrationsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<GetTimeRegistrationsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTimeRegistrationsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTimeRegistrationsResponse>(<any>null);
    }
}

export interface ISyncsClient {
    /**
     * Sync tracking locations
     * @param command Tracking locations data
     */
    tracking(command: TrackingSyncCommand): Observable<TrackingSyncResult>;
    /**
     * Sync observation
     * @param command Observation data
     */
    observation(command: ObservationSyncCommand): Observable<ObservationSyncResult>;
}

@Injectable()
export class SyncsClient implements ISyncsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Sync tracking locations
     * @param command Tracking locations data
     */
    tracking(command: TrackingSyncCommand): Observable<TrackingSyncResult> {
        let url_ = this.baseUrl + "/v1/Syncs/tracking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTracking(<any>response_);
                } catch (e) {
                    return <Observable<TrackingSyncResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackingSyncResult>><any>_observableThrow(response_);
        }));
    }

    protected processTracking(response: HttpResponseBase): Observable<TrackingSyncResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingSyncResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackingSyncResult>(<any>null);
    }

    /**
     * Sync observation
     * @param command Observation data
     */
    observation(command: ObservationSyncCommand): Observable<ObservationSyncResult> {
        let url_ = this.baseUrl + "/v1/Syncs/observation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObservation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObservation(<any>response_);
                } catch (e) {
                    return <Observable<ObservationSyncResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObservationSyncResult>><any>_observableThrow(response_);
        }));
    }

    protected processObservation(response: HttpResponseBase): Observable<ObservationSyncResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObservationSyncResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObservationSyncResult>(<any>null);
    }
}

export interface ISettingsClient {
    /**
     * Getting authorization settings for the GeoServer
     * @return Authorization keys for backoffice and mobile user
     */
    getGeoServerSettings(): Observable<GetGeoServerSettingsResponse>;
}

@Injectable()
export class SettingsClient implements ISettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Getting authorization settings for the GeoServer
     * @return Authorization keys for backoffice and mobile user
     */
    getGeoServerSettings(): Observable<GetGeoServerSettingsResponse> {
        let url_ = this.baseUrl + "/v1/Settings/geoserver";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeoServerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeoServerSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetGeoServerSettingsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeoServerSettingsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeoServerSettings(response: HttpResponseBase): Observable<GetGeoServerSettingsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeoServerSettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeoServerSettingsResponse>(<any>null);
    }
}

export interface IObservationsClient {
    /**
     * Get observations for given observation ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetObservationDetailsResponseItem[]>;
    /**
     * Creates an observation
     * @param command Observation data to be created
     * @return Observation details
     */
    update(command: ObservationUpdateCommand): Observable<GetObservationDetailsResponseItem>;
    /**
     * Get observations within bounding box
     * @param locationLatitude (optional) 
     * @param locationLongitude (optional) 
     * @param widthKilometers (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     */
    getObservations(locationLatitude: number | null | undefined, locationLongitude: number | null | undefined, widthKilometers: number | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetObservationDetailsResponseItem>;
    /**
     * Get observation details by id
     * @param id GUID of observation
     * @return Observation details.
     */
    get(id: string): Observable<GetObservationDetailsResponseItem>;
}

@Injectable()
export class ObservationsClient implements IObservationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Get observations for given observation ids
     * @param ids (optional) 
     */
    getMultiple(ids: string[] | null | undefined): Observable<GetObservationDetailsResponseItem[]> {
        let url_ = this.baseUrl + "/v1/Observations?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultiple(<any>response_);
                } catch (e) {
                    return <Observable<GetObservationDetailsResponseItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObservationDetailsResponseItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMultiple(response: HttpResponseBase): Observable<GetObservationDetailsResponseItem[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetObservationDetailsResponseItem.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObservationDetailsResponseItem[]>(<any>null);
    }

    /**
     * Creates an observation
     * @param command Observation data to be created
     * @return Observation details
     */
    update(command: ObservationUpdateCommand): Observable<GetObservationDetailsResponseItem> {
        let url_ = this.baseUrl + "/v1/Observations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GetObservationDetailsResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetObservationDetailsResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObservationDetailsResponseItem>(<any>null);
    }

    /**
     * Get observations within bounding box
     * @param locationLatitude (optional) 
     * @param locationLongitude (optional) 
     * @param widthKilometers (optional) 
     * @param pageSize (optional) 
     * @param currentPage (optional) 
     */
    getObservations(locationLatitude: number | null | undefined, locationLongitude: number | null | undefined, widthKilometers: number | undefined, pageSize: number | undefined, currentPage: number | undefined): Observable<PagedResponseOfGetObservationDetailsResponseItem> {
        let url_ = this.baseUrl + "/v1/Observations/get-observations?";
        if (locationLatitude !== undefined)
            url_ += "LocationLatitude=" + encodeURIComponent("" + locationLatitude) + "&"; 
        if (locationLongitude !== undefined)
            url_ += "LocationLongitude=" + encodeURIComponent("" + locationLongitude) + "&"; 
        if (widthKilometers === null)
            throw new Error("The parameter 'widthKilometers' cannot be null.");
        else if (widthKilometers !== undefined)
            url_ += "WidthKilometers=" + encodeURIComponent("" + widthKilometers) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObservations(<any>response_);
                } catch (e) {
                    return <Observable<PagedResponseOfGetObservationDetailsResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResponseOfGetObservationDetailsResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processGetObservations(response: HttpResponseBase): Observable<PagedResponseOfGetObservationDetailsResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfGetObservationDetailsResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResponseOfGetObservationDetailsResponseItem>(<any>null);
    }

    /**
     * Get observation details by id
     * @param id GUID of observation
     * @return Observation details.
     */
    get(id: string): Observable<GetObservationDetailsResponseItem> {
        let url_ = this.baseUrl + "/v1/Observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObservationDetailsResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetObservationDetailsResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetObservationDetailsResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObservationDetailsResponseItem>(<any>null);
    }
}

export interface IMapsClient {
    /**
     * Gets listing of all available overlay layers
     * @param orderedLayerCategoryCodes (optional) Category of layer
     * @param year (optional) Specific layers need year on which they get data
     * @param numberOfYears (optional) Maximum years go back in history
     * @return List of layers
     */
    overlayLayers(orderedLayerCategoryCodes: OverlayLayerCategoryCode[] | null | undefined, year: number | undefined, numberOfYears: number | undefined): Observable<ListResponseOfGetOverlayLayersResponseItem>;
    /**
     * Gets listing of all available background layers
     * @param query (optional) 
     * @return List of layers
     */
    backgroundLayers(query: GetBackgroundLayersQuery | null | undefined): Observable<ListResponseOfGetBackgroundLayersResponseItem>;
    /**
     * Gets listing of all map styles
     * @return List of map styles
     */
    styles(): Observable<GetMapStylesResponse>;
}

@Injectable()
export class MapsClient implements IMapsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Gets listing of all available overlay layers
     * @param orderedLayerCategoryCodes (optional) Category of layer
     * @param year (optional) Specific layers need year on which they get data
     * @param numberOfYears (optional) Maximum years go back in history
     * @return List of layers
     */
    overlayLayers(orderedLayerCategoryCodes: OverlayLayerCategoryCode[] | null | undefined, year: number | undefined, numberOfYears: number | undefined): Observable<ListResponseOfGetOverlayLayersResponseItem> {
        let url_ = this.baseUrl + "/v1/Maps/overlay-layers?";
        if (orderedLayerCategoryCodes !== undefined)
            orderedLayerCategoryCodes && orderedLayerCategoryCodes.forEach(item => { url_ += "OrderedLayerCategoryCodes=" + encodeURIComponent("" + item) + "&"; });
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&"; 
        if (numberOfYears === null)
            throw new Error("The parameter 'numberOfYears' cannot be null.");
        else if (numberOfYears !== undefined)
            url_ += "NumberOfYears=" + encodeURIComponent("" + numberOfYears) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOverlayLayers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOverlayLayers(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetOverlayLayersResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetOverlayLayersResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processOverlayLayers(response: HttpResponseBase): Observable<ListResponseOfGetOverlayLayersResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetOverlayLayersResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetOverlayLayersResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available background layers
     * @param query (optional) 
     * @return List of layers
     */
    backgroundLayers(query: GetBackgroundLayersQuery | null | undefined): Observable<ListResponseOfGetBackgroundLayersResponseItem> {
        let url_ = this.baseUrl + "/v1/Maps/background-layers?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackgroundLayers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackgroundLayers(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetBackgroundLayersResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetBackgroundLayersResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processBackgroundLayers(response: HttpResponseBase): Observable<ListResponseOfGetBackgroundLayersResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetBackgroundLayersResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetBackgroundLayersResponseItem>(<any>null);
    }

    /**
     * Gets listing of all map styles
     * @return List of map styles
     */
    styles(): Observable<GetMapStylesResponse> {
        let url_ = this.baseUrl + "/v1/Maps/styles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStyles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStyles(<any>response_);
                } catch (e) {
                    return <Observable<GetMapStylesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMapStylesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStyles(response: HttpResponseBase): Observable<GetMapStylesResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMapStylesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMapStylesResponse>(<any>null);
    }
}

export interface ILookupsClient {
    /**
     * Gets listing of all available Trap types
     * @param query (optional) 
     * @return List of trap types
     */
    trapTypes(query: GetTrapTypesQuery | null | undefined): Observable<ListResponseOfGetTrapTypesResponseItem>;
    /**
     * Gets listing of all available Catch types
     * @param query (optional) 
     * @return List of catch types
     */
    catchTypes(query: GetCatchTypesQuery | null | undefined): Observable<ListResponseOfGetCatchTypesResponseItem>;
    /**
     * Gets listing of all available Trapping types
     * @return List of trap types
     */
    trappingTypes(): Observable<ListResponseOfGetTrappingTypesResponseItem>;
    /**
     * Gets listing of all available time registration categories
     * @return List of time registration categories
     */
    timeRegistrationCategories(): Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem>;
}

@Injectable()
export class LookupsClient implements ILookupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Gets listing of all available Trap types
     * @param query (optional) 
     * @return List of trap types
     */
    trapTypes(query: GetTrapTypesQuery | null | undefined): Observable<ListResponseOfGetTrapTypesResponseItem> {
        let url_ = this.baseUrl + "/v1/trap-types?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrapTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrapTypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetTrapTypesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetTrapTypesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processTrapTypes(response: HttpResponseBase): Observable<ListResponseOfGetTrapTypesResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetTrapTypesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetTrapTypesResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available Catch types
     * @param query (optional) 
     * @return List of catch types
     */
    catchTypes(query: GetCatchTypesQuery | null | undefined): Observable<ListResponseOfGetCatchTypesResponseItem> {
        let url_ = this.baseUrl + "/v1/catch-types?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCatchTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCatchTypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetCatchTypesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetCatchTypesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processCatchTypes(response: HttpResponseBase): Observable<ListResponseOfGetCatchTypesResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetCatchTypesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetCatchTypesResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available Trapping types
     * @return List of trap types
     */
    trappingTypes(): Observable<ListResponseOfGetTrappingTypesResponseItem> {
        let url_ = this.baseUrl + "/v1/trapping-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrappingTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrappingTypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetTrappingTypesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetTrappingTypesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processTrappingTypes(response: HttpResponseBase): Observable<ListResponseOfGetTrappingTypesResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetTrappingTypesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetTrappingTypesResponseItem>(<any>null);
    }

    /**
     * Gets listing of all available time registration categories
     * @return List of time registration categories
     */
    timeRegistrationCategories(): Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem> {
        let url_ = this.baseUrl + "/v1/time-registration-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimeRegistrationCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimeRegistrationCategories(<any>response_);
                } catch (e) {
                    return <Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem>><any>_observableThrow(response_);
        }));
    }

    protected processTimeRegistrationCategories(response: HttpResponseBase): Observable<ListResponseOfGetTimeRegistrationCategoriesResponseItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResponseOfGetTimeRegistrationCategoriesResponseItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResponseOfGetTimeRegistrationCategoriesResponseItem>(<any>null);
    }
}

export interface IBlobStorageClient {
    /**
     * Gets SAS key from the BLOB storage
     * @return SAS key
     */
    getSasKey(): Observable<GetBlobStorageSasKeyResponse>;
}

@Injectable()
export class BlobStorageClient implements IBlobStorageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Gets SAS key from the BLOB storage
     * @return SAS key
     */
    getSasKey(): Observable<GetBlobStorageSasKeyResponse> {
        let url_ = this.baseUrl + "/v1/BlobStorage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSasKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSasKey(<any>response_);
                } catch (e) {
                    return <Observable<GetBlobStorageSasKeyResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBlobStorageSasKeyResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSasKey(response: HttpResponseBase): Observable<GetBlobStorageSasKeyResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBlobStorageSasKeyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBlobStorageSasKeyResponse>(<any>null);
    }
}

export interface IAreasClient {
    /**
     * Get Area details based on the geo location
     * @param lon (optional) Geographic longitude of the location in EPSG:28992 projection
     * @param lat (optional) Geographic latitude of the location in EPSG:28992 projection
     * @return AreaDetails object for the requested location
     */
    getLocationDetails(lon: number | undefined, lat: number | undefined): Observable<GetLocationAreaDetailsResponse>;
    /**
     * Get data for the catch area and its sub-area.
     * @param catchAreaId (optional) Id of the catch-area.
     * @param subAreaId (optional) Id of the sub-area.
     * @return Summary for catching traps, last week catches and by-catches, last week time registrations.
     */
    getLocationData(catchAreaId: string | undefined, subAreaId: string | undefined): Observable<GetLocationAreaDataResponse>;
    /**
     * Get CatchAreas based on filter and RayonId
     * @param filter (optional) The string used to filter CatchAreas by Name
     * @param rayonId (optional) The RayonId of the requested CatchAreas
     */
    getCatchAreas(filter: string | null | undefined, rayonId: string | null | undefined): Observable<GetAreaEntitiesResponse>;
    /**
     * Get SubAreas based on filter and CatchAreaId
     * @param filter (optional) The string used to filter SubAreas by Name
     * @param catchAreaId (optional) The CatchAreaId of the requested SubAreas
     */
    getSubAreas(filter: string | null | undefined, catchAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse>;
    /**
     * Get HourSquares based on filter and SubAreaId
     * @param filter (optional) The string used to filter HourSquares by Name
     * @param subAreaId (optional) The SubAreaId based on which to filter HourSquares
     */
    getHourSquares(filter: string | null | undefined, subAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse>;
}

@Injectable()
export class AreasClient implements IAreasClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Get Area details based on the geo location
     * @param lon (optional) Geographic longitude of the location in EPSG:28992 projection
     * @param lat (optional) Geographic latitude of the location in EPSG:28992 projection
     * @return AreaDetails object for the requested location
     */
    getLocationDetails(lon: number | undefined, lat: number | undefined): Observable<GetLocationAreaDetailsResponse> {
        let url_ = this.baseUrl + "/v1/Areas/location?";
        if (lon === null)
            throw new Error("The parameter 'lon' cannot be null.");
        else if (lon !== undefined)
            url_ += "lon=" + encodeURIComponent("" + lon) + "&"; 
        if (lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (lat !== undefined)
            url_ += "lat=" + encodeURIComponent("" + lat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetLocationAreaDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLocationAreaDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationDetails(response: HttpResponseBase): Observable<GetLocationAreaDetailsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLocationAreaDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLocationAreaDetailsResponse>(<any>null);
    }

    /**
     * Get data for the catch area and its sub-area.
     * @param catchAreaId (optional) Id of the catch-area.
     * @param subAreaId (optional) Id of the sub-area.
     * @return Summary for catching traps, last week catches and by-catches, last week time registrations.
     */
    getLocationData(catchAreaId: string | undefined, subAreaId: string | undefined): Observable<GetLocationAreaDataResponse> {
        let url_ = this.baseUrl + "/v1/Areas/location-data?";
        if (catchAreaId === null)
            throw new Error("The parameter 'catchAreaId' cannot be null.");
        else if (catchAreaId !== undefined)
            url_ += "catchAreaId=" + encodeURIComponent("" + catchAreaId) + "&"; 
        if (subAreaId === null)
            throw new Error("The parameter 'subAreaId' cannot be null.");
        else if (subAreaId !== undefined)
            url_ += "subAreaId=" + encodeURIComponent("" + subAreaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationData(<any>response_);
                } catch (e) {
                    return <Observable<GetLocationAreaDataResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLocationAreaDataResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationData(response: HttpResponseBase): Observable<GetLocationAreaDataResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLocationAreaDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLocationAreaDataResponse>(<any>null);
    }

    /**
     * Get CatchAreas based on filter and RayonId
     * @param filter (optional) The string used to filter CatchAreas by Name
     * @param rayonId (optional) The RayonId of the requested CatchAreas
     */
    getCatchAreas(filter: string | null | undefined, rayonId: string | null | undefined): Observable<GetAreaEntitiesResponse> {
        let url_ = this.baseUrl + "/v1/Areas/catch-areas?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (rayonId !== undefined)
            url_ += "rayonId=" + encodeURIComponent("" + rayonId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatchAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatchAreas(<any>response_);
                } catch (e) {
                    return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCatchAreas(response: HttpResponseBase): Observable<GetAreaEntitiesResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAreaEntitiesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaEntitiesResponse>(<any>null);
    }

    /**
     * Get SubAreas based on filter and CatchAreaId
     * @param filter (optional) The string used to filter SubAreas by Name
     * @param catchAreaId (optional) The CatchAreaId of the requested SubAreas
     */
    getSubAreas(filter: string | null | undefined, catchAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse> {
        let url_ = this.baseUrl + "/v1/Areas/sub-areas?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (catchAreaId !== undefined)
            url_ += "catchAreaId=" + encodeURIComponent("" + catchAreaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubAreas(<any>response_);
                } catch (e) {
                    return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubAreas(response: HttpResponseBase): Observable<GetAreaEntitiesResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAreaEntitiesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaEntitiesResponse>(<any>null);
    }

    /**
     * Get HourSquares based on filter and SubAreaId
     * @param filter (optional) The string used to filter HourSquares by Name
     * @param subAreaId (optional) The SubAreaId based on which to filter HourSquares
     */
    getHourSquares(filter: string | null | undefined, subAreaId: string | null | undefined): Observable<GetAreaEntitiesResponse> {
        let url_ = this.baseUrl + "/v1/Areas/hour-squares?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subAreaId !== undefined)
            url_ += "subAreaId=" + encodeURIComponent("" + subAreaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHourSquares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHourSquares(<any>response_);
                } catch (e) {
                    return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAreaEntitiesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetHourSquares(response: HttpResponseBase): Observable<GetAreaEntitiesResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAreaEntitiesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaEntitiesResponse>(<any>null);
    }
}

export interface IAccountClient {
    /**
     * Gets profile of the user
     * @return User profile as known in application
     */
    getUserProfile(): Observable<GetCurrentUserProfileResponse>;
    /**
     * Creates a new session for the given user
     * @return Indication if session creation was successful
     */
    createUserSession(): Observable<UserSessionCreateResult>;
    /**
     * Refreshes access token issued to a user
     * @param command The current value of the token
     * @return The new token value issued by authentication authority
     */
    refreshToken(command: SessionAccessTokenCreateCommand): Observable<SessionAccessTokenCreateResult>;
    /**
     * Logout user from the application with his Azure AD account
     * @return User email when logout is successful
     */
    logOut(): Observable<UserSessionTerminateResult>;
}

@Injectable()
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5450";
    }

    /**
     * Gets profile of the user
     * @return User profile as known in application
     */
    getUserProfile(): Observable<GetCurrentUserProfileResponse> {
        let url_ = this.baseUrl + "/v1/Account/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentUserProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentUserProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<GetCurrentUserProfileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentUserProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentUserProfileResponse>(<any>null);
    }

    /**
     * Creates a new session for the given user
     * @return Indication if session creation was successful
     */
    createUserSession(): Observable<UserSessionCreateResult> {
        let url_ = this.baseUrl + "/v1/Account/user-session";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserSession(<any>response_);
                } catch (e) {
                    return <Observable<UserSessionCreateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSessionCreateResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserSession(response: HttpResponseBase): Observable<UserSessionCreateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSessionCreateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSessionCreateResult>(<any>null);
    }

    /**
     * Refreshes access token issued to a user
     * @param command The current value of the token
     * @return The new token value issued by authentication authority
     */
    refreshToken(command: SessionAccessTokenCreateCommand): Observable<SessionAccessTokenCreateResult> {
        let url_ = this.baseUrl + "/v1/Account/access-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<SessionAccessTokenCreateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SessionAccessTokenCreateResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<SessionAccessTokenCreateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionAccessTokenCreateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SessionAccessTokenCreateResult>(<any>null);
    }

    /**
     * Logout user from the application with his Azure AD account
     * @return User email when logout is successful
     */
    logOut(): Observable<UserSessionTerminateResult> {
        let url_ = this.baseUrl + "/v1/Account/log-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<UserSessionTerminateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSessionTerminateResult>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<UserSessionTerminateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSessionTerminateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSessionTerminateResult>(<any>null);
    }
}

export class GetUserDetailsResponse implements IGetUserDetailsResponse {
    /** GUID of user */
    id?: string;
    /** Full name of the user */
    name?: string;
    /** Email, which is also account id */
    email?: string;
    /** Surname */
    surname?: string;
    /** Givenname, sometimes consists only of initials */
    givenName?: string;
    /** Indicator whether user is given access to the application */
    authorized?: boolean;
    /** Datetime this user has been created */
    createdOn?: Date;
    /** Date when some data has been changed for this user */
    updatedOn?: Date;
    /** List of roles that are assigned to the user */
    roles?: GetUserDetailsResponseRole[];
    /** Organization name user belongs to */
    organizationName?: string;
    /** Indication whether user complied with the organization policies to use application */
    confidentialityConfirmed?: boolean;
    /** Date when the user has been revoked access. This is used for annonymization purposes. */
    inactiveOn?: Date;

    constructor(data?: IGetUserDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.surname = _data["surname"];
            this.givenName = _data["givenName"];
            this.authorized = _data["authorized"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(GetUserDetailsResponseRole.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
            this.inactiveOn = _data["inactiveOn"] ? new Date(_data["inactiveOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["surname"] = this.surname;
        data["givenName"] = this.givenName;
        data["authorized"] = this.authorized;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        data["inactiveOn"] = this.inactiveOn ? this.inactiveOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetUserDetailsResponse {
    /** GUID of user */
    id?: string;
    /** Full name of the user */
    name?: string;
    /** Email, which is also account id */
    email?: string;
    /** Surname */
    surname?: string;
    /** Givenname, sometimes consists only of initials */
    givenName?: string;
    /** Indicator whether user is given access to the application */
    authorized?: boolean;
    /** Datetime this user has been created */
    createdOn?: Date;
    /** Date when some data has been changed for this user */
    updatedOn?: Date;
    /** List of roles that are assigned to the user */
    roles?: GetUserDetailsResponseRole[];
    /** Organization name user belongs to */
    organizationName?: string;
    /** Indication whether user complied with the organization policies to use application */
    confidentialityConfirmed?: boolean;
    /** Date when the user has been revoked access. This is used for annonymization purposes. */
    inactiveOn?: Date;
}

export class GetUserDetailsResponseRole implements IGetUserDetailsResponseRole {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string;
    /** Set of permission user has acquired through assigned roles */
    permissions?: GetUserDetailsResponsePermission[];

    constructor(data?: IGetUserDetailsResponseRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(GetUserDetailsResponsePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserDetailsResponseRole {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsResponseRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserDetailsResponseRole {
    /** GUID of the role */
    id?: string;
    /** Name of the role */
    name?: string;
    /** Set of permission user has acquired through assigned roles */
    permissions?: GetUserDetailsResponsePermission[];
}

export class GetUserDetailsResponsePermission implements IGetUserDetailsResponsePermission {
    /** GUID of permission */
    id?: PermissionId;
    /** Name of the permission */
    name?: string;

    constructor(data?: IGetUserDetailsResponsePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetUserDetailsResponsePermission {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsResponsePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetUserDetailsResponsePermission {
    /** GUID of permission */
    id?: PermissionId;
    /** Name of the permission */
    name?: string;
}

export enum PermissionId {
    MapRead = 1,
    MapContentRead = 2,
    MapContentWrite = 3,
    ReportReadWrite = 4,
    TimeRegistrationPersonalReadWrite = 5,
    TimeRegistrationManagementReadWrite = 6,
    UserReadWrite = 7,
    Management = 8,
    AssignMaintainerRole = 9,
    ReadOnly = 10,
    ApiPublic = 11,
    ApiPrivate = 12,
    Mobile = 100,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class UserUpdateConfidentialityCommand implements IUserUpdateConfidentialityCommand {
    /** GUID of the user */
    id?: string;
    /** Indicator whether user agreed with organization policies */
    confidentialityConfirmed?: boolean;

    constructor(data?: IUserUpdateConfidentialityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
        }
    }

    static fromJS(data: any): UserUpdateConfidentialityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateConfidentialityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        return data; 
    }
}

export interface IUserUpdateConfidentialityCommand {
    /** GUID of the user */
    id?: string;
    /** Indicator whether user agreed with organization policies */
    confidentialityConfirmed?: boolean;
}

export class GetTrapDetailsTrapItem implements IGetTrapDetailsTrapItem {
    /** GUID of trap */
    id?: string;
    /** Name of the trap type */
    type?: string;
    /** GUID of the trap type */
    trapTypeId?: string;
    /** GUID of the trapping type */
    trappingTypeId?: string;
    /** Trap status: catching, non catching, deleted */
    status?: TrapStatus;
    /** Remarks entered by a trapper */
    remarks?: string | undefined;
    /** Number of traps */
    numberOfTraps?: number;
    /** Longitude of trap where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
    /** Name of user who created this trap */
    createdBy?: string;
    /** Created on of record in back-office */
    createdOn?: Date;
    /** Date when the trap has been created on mobile by trapper */
    recordedOn?: Date;
    /** Name of user who updated this trap */
    updatedBy?: string;
    /** Updated on */
    updatedOn?: Date;
    /** List of catch detail on this trap */
    catches?: GetCatchDetailsCatchItem[];
    /** Rayon */
    rayon?: string;
    /** Sub Area */
    subArea?: string;
    /** Cath Area */
    catchArea?: string;
    /** GUID of the user who created this trap */
    createdById?: string;

    constructor(data?: IGetTrapDetailsTrapItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.trapTypeId = _data["trapTypeId"];
            this.trappingTypeId = _data["trappingTypeId"];
            this.status = _data["status"];
            this.remarks = _data["remarks"];
            this.numberOfTraps = _data["numberOfTraps"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["catches"])) {
                this.catches = [] as any;
                for (let item of _data["catches"])
                    this.catches!.push(GetCatchDetailsCatchItem.fromJS(item));
            }
            this.rayon = _data["rayon"];
            this.subArea = _data["subArea"];
            this.catchArea = _data["catchArea"];
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): GetTrapDetailsTrapItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapDetailsTrapItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["trapTypeId"] = this.trapTypeId;
        data["trappingTypeId"] = this.trappingTypeId;
        data["status"] = this.status;
        data["remarks"] = this.remarks;
        data["numberOfTraps"] = this.numberOfTraps;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        if (Array.isArray(this.catches)) {
            data["catches"] = [];
            for (let item of this.catches)
                data["catches"].push(item.toJSON());
        }
        data["rayon"] = this.rayon;
        data["subArea"] = this.subArea;
        data["catchArea"] = this.catchArea;
        data["createdById"] = this.createdById;
        return data; 
    }
}

export interface IGetTrapDetailsTrapItem {
    /** GUID of trap */
    id?: string;
    /** Name of the trap type */
    type?: string;
    /** GUID of the trap type */
    trapTypeId?: string;
    /** GUID of the trapping type */
    trappingTypeId?: string;
    /** Trap status: catching, non catching, deleted */
    status?: TrapStatus;
    /** Remarks entered by a trapper */
    remarks?: string | undefined;
    /** Number of traps */
    numberOfTraps?: number;
    /** Longitude of trap where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
    /** Name of user who created this trap */
    createdBy?: string;
    /** Created on of record in back-office */
    createdOn?: Date;
    /** Date when the trap has been created on mobile by trapper */
    recordedOn?: Date;
    /** Name of user who updated this trap */
    updatedBy?: string;
    /** Updated on */
    updatedOn?: Date;
    /** List of catch detail on this trap */
    catches?: GetCatchDetailsCatchItem[];
    /** Rayon */
    rayon?: string;
    /** Sub Area */
    subArea?: string;
    /** Cath Area */
    catchArea?: string;
    /** GUID of the user who created this trap */
    createdById?: string;
}

export enum TrapStatus {
    Catching = 1,
    NotCatching = 2,
    Removed = 3,
}

export class GetCatchDetailsCatchItem implements IGetCatchDetailsCatchItem {
    /** GUID of catch */
    id?: string;
    /** Name of the type of catch */
    type?: string;
    /** Number of catches of this type */
    number?: number;
    /** Indicator catch or by-catch */
    isByCatch?: boolean;
    /** Name of the user who created the catch */
    createdBy?: string;
    /** GUID of the user who created the catch */
    createdById?: string;
    /** Date when the catch is stored in database */
    createdOn?: Date;
    /** Date when the catch is registered on mobile */
    recordedOn?: Date;
    /** GUID of the catch type */
    catchTypeId?: string;
    /** Catch status: written, closed, completed */
    status?: CatchStatus;
    /** Indicator weather catch can be edited */
    canBeEdited?: boolean;

    constructor(data?: IGetCatchDetailsCatchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.number = _data["number"];
            this.isByCatch = _data["isByCatch"];
            this.createdBy = _data["createdBy"];
            this.createdById = _data["createdById"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.catchTypeId = _data["catchTypeId"];
            this.status = _data["status"];
            this.canBeEdited = _data["canBeEdited"];
        }
    }

    static fromJS(data: any): GetCatchDetailsCatchItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchDetailsCatchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["number"] = this.number;
        data["isByCatch"] = this.isByCatch;
        data["createdBy"] = this.createdBy;
        data["createdById"] = this.createdById;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["catchTypeId"] = this.catchTypeId;
        data["status"] = this.status;
        data["canBeEdited"] = this.canBeEdited;
        return data; 
    }
}

export interface IGetCatchDetailsCatchItem {
    /** GUID of catch */
    id?: string;
    /** Name of the type of catch */
    type?: string;
    /** Number of catches of this type */
    number?: number;
    /** Indicator catch or by-catch */
    isByCatch?: boolean;
    /** Name of the user who created the catch */
    createdBy?: string;
    /** GUID of the user who created the catch */
    createdById?: string;
    /** Date when the catch is stored in database */
    createdOn?: Date;
    /** Date when the catch is registered on mobile */
    recordedOn?: Date;
    /** GUID of the catch type */
    catchTypeId?: string;
    /** Catch status: written, closed, completed */
    status?: CatchStatus;
    /** Indicator weather catch can be edited */
    canBeEdited?: boolean;
}

export enum CatchStatus {
    Written = 1,
    Closed = 2,
    Completed = 3,
}

export class PagedResponseOfGetTrapDetailsTrapItem implements IPagedResponseOfGetTrapDetailsTrapItem {
    items?: GetTrapDetailsTrapItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetTrapDetailsTrapItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrapDetailsTrapItem.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetTrapDetailsTrapItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetTrapDetailsTrapItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetTrapDetailsTrapItem {
    items?: GetTrapDetailsTrapItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetMySummaryResponse implements IGetMySummaryResponse {
    /** Amount of catches this week */
    catchesThisWeek?: number;
    /** Amount of catching traps */
    outstandingTraps?: number;
    /** List of trap details */
    trapDetails?: GetMySummaryTrapInfo[];

    constructor(data?: IGetMySummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catchesThisWeek = _data["catchesThisWeek"];
            this.outstandingTraps = _data["outstandingTraps"];
            if (Array.isArray(_data["trapDetails"])) {
                this.trapDetails = [] as any;
                for (let item of _data["trapDetails"])
                    this.trapDetails!.push(GetMySummaryTrapInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMySummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMySummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catchesThisWeek"] = this.catchesThisWeek;
        data["outstandingTraps"] = this.outstandingTraps;
        if (Array.isArray(this.trapDetails)) {
            data["trapDetails"] = [];
            for (let item of this.trapDetails)
                data["trapDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMySummaryResponse {
    /** Amount of catches this week */
    catchesThisWeek?: number;
    /** Amount of catching traps */
    outstandingTraps?: number;
    /** List of trap details */
    trapDetails?: GetMySummaryTrapInfo[];
}

export class GetMySummaryTrapInfo implements IGetMySummaryTrapInfo {
    /** Label consisting of trap type and trapping type */
    typeLabel?: string;
    /** Date when the trap is created */
    dateCreated?: Date;
    /** Amount of day passed since last catch */
    daysSinceCatch?: number;

    constructor(data?: IGetMySummaryTrapInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeLabel = _data["typeLabel"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.daysSinceCatch = _data["daysSinceCatch"];
        }
    }

    static fromJS(data: any): GetMySummaryTrapInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetMySummaryTrapInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeLabel"] = this.typeLabel;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["daysSinceCatch"] = this.daysSinceCatch;
        return data; 
    }
}

export interface IGetMySummaryTrapInfo {
    /** Label consisting of trap type and trapping type */
    typeLabel?: string;
    /** Date when the trap is created */
    dateCreated?: Date;
    /** Amount of day passed since last catch */
    daysSinceCatch?: number;
}

export class PagedResponseOfGetTrapHistoriesHistoryItem implements IPagedResponseOfGetTrapHistoriesHistoryItem {
    items?: GetTrapHistoriesHistoryItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetTrapHistoriesHistoryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrapHistoriesHistoryItem.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetTrapHistoriesHistoryItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetTrapHistoriesHistoryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetTrapHistoriesHistoryItem {
    items?: GetTrapHistoriesHistoryItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class GetTrapHistoriesHistoryItem implements IGetTrapHistoriesHistoryItem {
    /** GUID of user who created by */
    createdBy?: string;
    /** Recorded on */
    recordedOn?: Date;
    /** Message while creation */
    message?: string;

    constructor(data?: IGetTrapHistoriesHistoryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): GetTrapHistoriesHistoryItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapHistoriesHistoryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["message"] = this.message;
        return data; 
    }
}

export interface IGetTrapHistoriesHistoryItem {
    /** GUID of user who created by */
    createdBy?: string;
    /** Recorded on */
    recordedOn?: Date;
    /** Message while creation */
    message?: string;
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        this.errors![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["errors"][key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class TrapCreateOrUpdateCommand implements ITrapCreateOrUpdateCommand {
    /** GUID of trap */
    id!: string;
    /** Date when the trap has been created on mobile by trapper */
    recordedOn!: Date;
    /** Number of traps */
    numberOfTraps!: number;
    /** Trap status: catching, non catching, deleted */
    status!: TrapStatus;
    /** Longitude of trap where it is registered */
    longitude!: number;
    /** Latitude of trap where it is registered */
    latitude!: number;
    /** GUID of the trap type */
    trapTypeId!: string;
    /** Remarks entered by a trapper */
    remarks?: string | undefined;
    /** List of catches registered on this trap */
    catches?: CatchCreateOrUpdateCommand[];
    /** Hint for creation of trap */
    shouldCreate?: boolean;
    catchesToCreate?: CatchCreateOrUpdateCommand[];
    catchesToRemove?: CatchCreateOrUpdateCommand[];

    constructor(data?: ITrapCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.numberOfTraps = _data["numberOfTraps"];
            this.status = _data["status"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.trapTypeId = _data["trapTypeId"];
            this.remarks = _data["remarks"];
            if (Array.isArray(_data["catches"])) {
                this.catches = [] as any;
                for (let item of _data["catches"])
                    this.catches!.push(CatchCreateOrUpdateCommand.fromJS(item));
            }
            this.shouldCreate = _data["shouldCreate"];
            if (Array.isArray(_data["catchesToCreate"])) {
                this.catchesToCreate = [] as any;
                for (let item of _data["catchesToCreate"])
                    this.catchesToCreate!.push(CatchCreateOrUpdateCommand.fromJS(item));
            }
            if (Array.isArray(_data["catchesToRemove"])) {
                this.catchesToRemove = [] as any;
                for (let item of _data["catchesToRemove"])
                    this.catchesToRemove!.push(CatchCreateOrUpdateCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrapCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TrapCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["numberOfTraps"] = this.numberOfTraps;
        data["status"] = this.status;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["trapTypeId"] = this.trapTypeId;
        data["remarks"] = this.remarks;
        if (Array.isArray(this.catches)) {
            data["catches"] = [];
            for (let item of this.catches)
                data["catches"].push(item.toJSON());
        }
        data["shouldCreate"] = this.shouldCreate;
        if (Array.isArray(this.catchesToCreate)) {
            data["catchesToCreate"] = [];
            for (let item of this.catchesToCreate)
                data["catchesToCreate"].push(item.toJSON());
        }
        if (Array.isArray(this.catchesToRemove)) {
            data["catchesToRemove"] = [];
            for (let item of this.catchesToRemove)
                data["catchesToRemove"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrapCreateOrUpdateCommand {
    /** GUID of trap */
    id: string;
    /** Date when the trap has been created on mobile by trapper */
    recordedOn: Date;
    /** Number of traps */
    numberOfTraps: number;
    /** Trap status: catching, non catching, deleted */
    status: TrapStatus;
    /** Longitude of trap where it is registered */
    longitude: number;
    /** Latitude of trap where it is registered */
    latitude: number;
    /** GUID of the trap type */
    trapTypeId: string;
    /** Remarks entered by a trapper */
    remarks?: string | undefined;
    /** List of catches registered on this trap */
    catches?: CatchCreateOrUpdateCommand[];
    /** Hint for creation of trap */
    shouldCreate?: boolean;
    catchesToCreate?: CatchCreateOrUpdateCommand[];
    catchesToRemove?: CatchCreateOrUpdateCommand[];
}

export class CatchCreateOrUpdateCommand implements ICatchCreateOrUpdateCommand {
    /** GUID of the catch */
    id!: string;
    /** Recorded on */
    recordedOn!: Date;
    /** Number of catches */
    number!: number;
    /** Catch status */
    status!: CatchStatus;
    /** GUID of the trap the catch is registered on */
    trapId!: string;
    /** GUID of the catch type */
    catchTypeId!: string;
    /** When set to true, the catch will be removed from database  */
    markedForRemoval!: boolean;

    constructor(data?: ICatchCreateOrUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.status = _data["status"];
            this.trapId = _data["trapId"];
            this.catchTypeId = _data["catchTypeId"];
            this.markedForRemoval = _data["markedForRemoval"];
        }
    }

    static fromJS(data: any): CatchCreateOrUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatchCreateOrUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["status"] = this.status;
        data["trapId"] = this.trapId;
        data["catchTypeId"] = this.catchTypeId;
        data["markedForRemoval"] = this.markedForRemoval;
        return data; 
    }
}

export interface ICatchCreateOrUpdateCommand {
    /** GUID of the catch */
    id: string;
    /** Recorded on */
    recordedOn: Date;
    /** Number of catches */
    number: number;
    /** Catch status */
    status: CatchStatus;
    /** GUID of the trap the catch is registered on */
    trapId: string;
    /** GUID of the catch type */
    catchTypeId: string;
    /** When set to true, the catch will be removed from database  */
    markedForRemoval: boolean;
}

export class GetTimeRegistrationsResponse implements IGetTimeRegistrationsResponse {
    /** Day this time registration applies to */
    date?: Date;
    canAddNew?: boolean;
    /** List of time registrations for this day */
    items?: GetTimeRegistrationsResponseItem[];
    /** List of general time registrations for this day */
    generalItems?: GetTimeRegistrationsResponseGeneralItem[];
    totalTimeOfFilteredOutItems?: number;

    constructor(data?: IGetTimeRegistrationsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.canAddNew = _data["canAddNew"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTimeRegistrationsResponseItem.fromJS(item));
            }
            if (Array.isArray(_data["generalItems"])) {
                this.generalItems = [] as any;
                for (let item of _data["generalItems"])
                    this.generalItems!.push(GetTimeRegistrationsResponseGeneralItem.fromJS(item));
            }
            this.totalTimeOfFilteredOutItems = _data["totalTimeOfFilteredOutItems"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["canAddNew"] = this.canAddNew;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.generalItems)) {
            data["generalItems"] = [];
            for (let item of this.generalItems)
                data["generalItems"].push(item.toJSON());
        }
        data["totalTimeOfFilteredOutItems"] = this.totalTimeOfFilteredOutItems;
        return data; 
    }
}

export interface IGetTimeRegistrationsResponse {
    /** Day this time registration applies to */
    date?: Date;
    canAddNew?: boolean;
    /** List of time registrations for this day */
    items?: GetTimeRegistrationsResponseItem[];
    /** List of general time registrations for this day */
    generalItems?: GetTimeRegistrationsResponseGeneralItem[];
    totalTimeOfFilteredOutItems?: number;
}

export class GetTimeRegistrationsResponseItem implements IGetTimeRegistrationsResponseItem {
    /** GUID of the time registration record */
    id?: string;
    /** Category */
    category?: NamedEntityItem | undefined;
    /** Catch Area */
    catchArea?: NamedEntityItem | undefined;
    /** Sub Area */
    subArea?: NamedEntityItem | undefined;
    /** Hour Square (Atlas Block) */
    hourSquare?: NamedEntityItem | undefined;
    /** Trapping type */
    trappingType?: NamedEntityItem | undefined;
    /** Day for which this time is logged */
    date?: Date;
    /** Status of this time registration record */
    status?: TimeRegistrationStatus;
    /** Amount of hours */
    hours?: number;
    /** Amount of minutes */
    minutes?: number;

    constructor(data?: IGetTimeRegistrationsResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"] ? NamedEntityItem.fromJS(_data["category"]) : <any>undefined;
            this.catchArea = _data["catchArea"] ? NamedEntityItem.fromJS(_data["catchArea"]) : <any>undefined;
            this.subArea = _data["subArea"] ? NamedEntityItem.fromJS(_data["subArea"]) : <any>undefined;
            this.hourSquare = _data["hourSquare"] ? NamedEntityItem.fromJS(_data["hourSquare"]) : <any>undefined;
            this.trappingType = _data["trappingType"] ? NamedEntityItem.fromJS(_data["trappingType"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationsResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["catchArea"] = this.catchArea ? this.catchArea.toJSON() : <any>undefined;
        data["subArea"] = this.subArea ? this.subArea.toJSON() : <any>undefined;
        data["hourSquare"] = this.hourSquare ? this.hourSquare.toJSON() : <any>undefined;
        data["trappingType"] = this.trappingType ? this.trappingType.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        return data; 
    }
}

export interface IGetTimeRegistrationsResponseItem {
    /** GUID of the time registration record */
    id?: string;
    /** Category */
    category?: NamedEntityItem | undefined;
    /** Catch Area */
    catchArea?: NamedEntityItem | undefined;
    /** Sub Area */
    subArea?: NamedEntityItem | undefined;
    /** Hour Square (Atlas Block) */
    hourSquare?: NamedEntityItem | undefined;
    /** Trapping type */
    trappingType?: NamedEntityItem | undefined;
    /** Day for which this time is logged */
    date?: Date;
    /** Status of this time registration record */
    status?: TimeRegistrationStatus;
    /** Amount of hours */
    hours?: number;
    /** Amount of minutes */
    minutes?: number;
}

export class NamedEntityItem implements INamedEntityItem {
    id?: string;
    name?: string;

    constructor(data?: INamedEntityItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NamedEntityItem {
        data = typeof data === 'object' ? data : {};
        let result = new NamedEntityItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface INamedEntityItem {
    id?: string;
    name?: string;
}

export enum TimeRegistrationStatus {
    Written = 1,
    Closed = 2,
    Completed = 3,
}

export class GetTimeRegistrationsResponseGeneralItem implements IGetTimeRegistrationsResponseGeneralItem {
    /** GUID of the general time registration record */
    id?: string;
    /** Category */
    category?: NamedEntityItem | undefined;
    /** Day for which this time is logged */
    date?: Date;
    /** Status of this time general registration record */
    status?: TimeRegistrationStatus;
    /** Amount of spent hours */
    hours?: number;
    /** Amount of spent minutes */
    minutes?: number;

    constructor(data?: IGetTimeRegistrationsResponseGeneralItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"] ? NamedEntityItem.fromJS(_data["category"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationsResponseGeneralItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationsResponseGeneralItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        return data; 
    }
}

export interface IGetTimeRegistrationsResponseGeneralItem {
    /** GUID of the general time registration record */
    id?: string;
    /** Category */
    category?: NamedEntityItem | undefined;
    /** Day for which this time is logged */
    date?: Date;
    /** Status of this time general registration record */
    status?: TimeRegistrationStatus;
    /** Amount of spent hours */
    hours?: number;
    /** Amount of spent minutes */
    minutes?: number;
}

export class TimeRegistrationsEditCommand implements ITimeRegistrationsEditCommand {
    /** GUID of the Sub Area Hour Square where time is registered */
    subAreaHourSquareId?: string | undefined;
    /** First day of week this time registration applies to */
    startDate?: Date;
    /** Last day of week this time registration applies to */
    endDate?: Date;
    /** List of time registrations per day */
    daysOfWeek?: TimeRegistrationsEditCommandTimeRegistrationsOfDate[];
    /** List of catches in that week */
    catches?: TimeRegistrationsEditCatchItem[];
    /** List of general time registrations per day */
    timeRegistrationGeneralItems?: TimeRegistrationsEditTimeRegistrationGeneral[];

    constructor(data?: ITimeRegistrationsEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subAreaHourSquareId = _data["subAreaHourSquareId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(TimeRegistrationsEditCommandTimeRegistrationsOfDate.fromJS(item));
            }
            if (Array.isArray(_data["catches"])) {
                this.catches = [] as any;
                for (let item of _data["catches"])
                    this.catches!.push(TimeRegistrationsEditCatchItem.fromJS(item));
            }
            if (Array.isArray(_data["timeRegistrationGeneralItems"])) {
                this.timeRegistrationGeneralItems = [] as any;
                for (let item of _data["timeRegistrationGeneralItems"])
                    this.timeRegistrationGeneralItems!.push(TimeRegistrationsEditTimeRegistrationGeneral.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subAreaHourSquareId"] = this.subAreaHourSquareId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item.toJSON());
        }
        if (Array.isArray(this.catches)) {
            data["catches"] = [];
            for (let item of this.catches)
                data["catches"].push(item.toJSON());
        }
        if (Array.isArray(this.timeRegistrationGeneralItems)) {
            data["timeRegistrationGeneralItems"] = [];
            for (let item of this.timeRegistrationGeneralItems)
                data["timeRegistrationGeneralItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITimeRegistrationsEditCommand {
    /** GUID of the Sub Area Hour Square where time is registered */
    subAreaHourSquareId?: string | undefined;
    /** First day of week this time registration applies to */
    startDate?: Date;
    /** Last day of week this time registration applies to */
    endDate?: Date;
    /** List of time registrations per day */
    daysOfWeek?: TimeRegistrationsEditCommandTimeRegistrationsOfDate[];
    /** List of catches in that week */
    catches?: TimeRegistrationsEditCatchItem[];
    /** List of general time registrations per day */
    timeRegistrationGeneralItems?: TimeRegistrationsEditTimeRegistrationGeneral[];
}

export class TimeRegistrationsEditCommandTimeRegistrationsOfDate implements ITimeRegistrationsEditCommandTimeRegistrationsOfDate {
    /** Day this time registration applies to */
    date?: Date;
    /** List of time registratios for current day */
    items?: TimeRegistrationsEditCommandItem[] | undefined;

    constructor(data?: ITimeRegistrationsEditCommandTimeRegistrationsOfDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TimeRegistrationsEditCommandItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCommandTimeRegistrationsOfDate {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCommandTimeRegistrationsOfDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITimeRegistrationsEditCommandTimeRegistrationsOfDate {
    /** Day this time registration applies to */
    date?: Date;
    /** List of time registratios for current day */
    items?: TimeRegistrationsEditCommandItem[] | undefined;
}

export class TimeRegistrationsEditCommandItem implements ITimeRegistrationsEditCommandItem {
    /** GUID of this time registration */
    id?: string | undefined;
    /** Day this record applies to */
    date?: Date;
    /** Sub Area guid */
    subAreaId?: string;
    /** Hour Square guid */
    hourSquareId?: string;
    /** GUID of the trapping type the time applies to */
    trappingTypeId?: string;
    /** Amount of hours */
    hours?: number;
    /** Amount of minutes */
    minutes?: number;
    /** Status of this time registration record */
    status?: TimeRegistrationStatus;

    constructor(data?: ITimeRegistrationsEditCommandItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.subAreaId = _data["subAreaId"];
            this.hourSquareId = _data["hourSquareId"];
            this.trappingTypeId = _data["trappingTypeId"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCommandItem {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCommandItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["subAreaId"] = this.subAreaId;
        data["hourSquareId"] = this.hourSquareId;
        data["trappingTypeId"] = this.trappingTypeId;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        data["status"] = this.status;
        return data; 
    }
}

export interface ITimeRegistrationsEditCommandItem {
    /** GUID of this time registration */
    id?: string | undefined;
    /** Day this record applies to */
    date?: Date;
    /** Sub Area guid */
    subAreaId?: string;
    /** Hour Square guid */
    hourSquareId?: string;
    /** GUID of the trapping type the time applies to */
    trappingTypeId?: string;
    /** Amount of hours */
    hours?: number;
    /** Amount of minutes */
    minutes?: number;
    /** Status of this time registration record */
    status?: TimeRegistrationStatus;
}

export class TimeRegistrationsEditCatchItem implements ITimeRegistrationsEditCatchItem {
    /** GUID of the catch */
    id?: string;
    /** Created on */
    createdOn?: Date;
    /** Catch type guid for this catch */
    catchTypeId?: string;
    /** Number of catches */
    number?: number;
    /** Status of this catch */
    status?: CatchStatus;
    /** Indicator if this is catch or by-catch */
    isByCatch?: boolean;

    constructor(data?: ITimeRegistrationsEditCatchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.catchTypeId = _data["catchTypeId"];
            this.number = _data["number"];
            this.status = _data["status"];
            this.isByCatch = _data["isByCatch"];
        }
    }

    static fromJS(data: any): TimeRegistrationsEditCatchItem {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditCatchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["catchTypeId"] = this.catchTypeId;
        data["number"] = this.number;
        data["status"] = this.status;
        data["isByCatch"] = this.isByCatch;
        return data; 
    }
}

export interface ITimeRegistrationsEditCatchItem {
    /** GUID of the catch */
    id?: string;
    /** Created on */
    createdOn?: Date;
    /** Catch type guid for this catch */
    catchTypeId?: string;
    /** Number of catches */
    number?: number;
    /** Status of this catch */
    status?: CatchStatus;
    /** Indicator if this is catch or by-catch */
    isByCatch?: boolean;
}

export class TimeRegistrationsEditTimeRegistrationGeneral implements ITimeRegistrationsEditTimeRegistrationGeneral {
    id?: string | undefined;
    date?: Date;
    categoryId?: string;
    status?: TimeRegistrationStatus;
    hours?: number;
    minutes?: number;

    constructor(data?: ITimeRegistrationsEditTimeRegistrationGeneral) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.status = _data["status"];
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
        }
    }

    static fromJS(data: any): TimeRegistrationsEditTimeRegistrationGeneral {
        data = typeof data === 'object' ? data : {};
        let result = new TimeRegistrationsEditTimeRegistrationGeneral();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["status"] = this.status;
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        return data; 
    }
}

export interface ITimeRegistrationsEditTimeRegistrationGeneral {
    id?: string | undefined;
    date?: Date;
    categoryId?: string;
    status?: TimeRegistrationStatus;
    hours?: number;
    minutes?: number;
}

export class TrackingSyncResult implements ITrackingSyncResult {

    constructor(data?: ITrackingSyncResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TrackingSyncResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingSyncResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ITrackingSyncResult {
}

export class TrackingSyncCommand implements ITrackingSyncCommand {
    trackingLocations?: TrackingSyncCommandTrackingItem[];

    constructor(data?: ITrackingSyncCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["trackingLocations"])) {
                this.trackingLocations = [] as any;
                for (let item of _data["trackingLocations"])
                    this.trackingLocations!.push(TrackingSyncCommandTrackingItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrackingSyncCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingSyncCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.trackingLocations)) {
            data["trackingLocations"] = [];
            for (let item of this.trackingLocations)
                data["trackingLocations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrackingSyncCommand {
    trackingLocations?: TrackingSyncCommandTrackingItem[];
}

export class TrackingSyncCommandTrackingItem implements ITrackingSyncCommandTrackingItem {
    /** GUID of the tracking record */
    id?: string | undefined;
    /** Longitude of registered position */
    longitude?: number;
    /** Latitude of registered positions */
    latitude?: number;
    /** Date when the position is registered */
    recordedOn?: Date;
    /** trapping type while tracking */
    trappingTypeId?: string;
    /** session id for tracking */
    sessionId?: string;
    /** Indicator whether tracking could be used for timewriting */
    isTimewriting?: boolean;
    /** Indicator whether tracking could be used for tracking lines */
    isTrackingMap?: boolean;
    /** Indicator whether other traps can see your position */
    isTrackingPrivate?: boolean;

    constructor(data?: ITrackingSyncCommandTrackingItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.trappingTypeId = _data["trappingTypeId"];
            this.sessionId = _data["sessionId"];
            this.isTimewriting = _data["isTimewriting"];
            this.isTrackingMap = _data["isTrackingMap"];
            this.isTrackingPrivate = _data["isTrackingPrivate"];
        }
    }

    static fromJS(data: any): TrackingSyncCommandTrackingItem {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingSyncCommandTrackingItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["trappingTypeId"] = this.trappingTypeId;
        data["sessionId"] = this.sessionId;
        data["isTimewriting"] = this.isTimewriting;
        data["isTrackingMap"] = this.isTrackingMap;
        data["isTrackingPrivate"] = this.isTrackingPrivate;
        return data; 
    }
}

export interface ITrackingSyncCommandTrackingItem {
    /** GUID of the tracking record */
    id?: string | undefined;
    /** Longitude of registered position */
    longitude?: number;
    /** Latitude of registered positions */
    latitude?: number;
    /** Date when the position is registered */
    recordedOn?: Date;
    /** trapping type while tracking */
    trappingTypeId?: string;
    /** session id for tracking */
    sessionId?: string;
    /** Indicator whether tracking could be used for timewriting */
    isTimewriting?: boolean;
    /** Indicator whether tracking could be used for tracking lines */
    isTrackingMap?: boolean;
    /** Indicator whether other traps can see your position */
    isTrackingPrivate?: boolean;
}

export class ObservationSyncResult implements IObservationSyncResult {
    savedItems?: ObservationSyncResultResultItem[];
    storageAccessKey?: string;

    constructor(data?: IObservationSyncResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["savedItems"])) {
                this.savedItems = [] as any;
                for (let item of _data["savedItems"])
                    this.savedItems!.push(ObservationSyncResultResultItem.fromJS(item));
            }
            this.storageAccessKey = _data["storageAccessKey"];
        }
    }

    static fromJS(data: any): ObservationSyncResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationSyncResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.savedItems)) {
            data["savedItems"] = [];
            for (let item of this.savedItems)
                data["savedItems"].push(item.toJSON());
        }
        data["storageAccessKey"] = this.storageAccessKey;
        return data; 
    }
}

export interface IObservationSyncResult {
    savedItems?: ObservationSyncResultResultItem[];
    storageAccessKey?: string;
}

export class ObservationSyncResultResultItem implements IObservationSyncResultResultItem {
    id?: string;
    isNew?: boolean;

    constructor(data?: IObservationSyncResultResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isNew = _data["isNew"];
        }
    }

    static fromJS(data: any): ObservationSyncResultResultItem {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationSyncResultResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isNew"] = this.isNew;
        return data; 
    }
}

export interface IObservationSyncResultResultItem {
    id?: string;
    isNew?: boolean;
}

export class ObservationSyncCommand implements IObservationSyncCommand {
    observations?: ObservationSyncCommandObservationItem[];

    constructor(data?: IObservationSyncCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(ObservationSyncCommandObservationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObservationSyncCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationSyncCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IObservationSyncCommand {
    observations?: ObservationSyncCommandObservationItem[];
}

export class ObservationSyncCommandObservationItem implements IObservationSyncCommandObservationItem {
    /** GUID of the observation */
    id!: string;
    /** Longitude where observation is registered */
    longitude?: number;
    /** Latitude where observation is registered */
    latitude?: number;
    /** Type of observation (schade, other) */
    type?: number;
    /** Remarks entered by the trapper */
    remarks?: string | undefined;
    /** Creation date of the observation */
    recordedOn?: Date;
    /** Indicator whether a photo has been made */
    hasPhoto?: boolean;

    constructor(data?: IObservationSyncCommandObservationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.type = _data["type"];
            this.remarks = _data["remarks"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.hasPhoto = _data["hasPhoto"];
        }
    }

    static fromJS(data: any): ObservationSyncCommandObservationItem {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationSyncCommandObservationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["type"] = this.type;
        data["remarks"] = this.remarks;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["hasPhoto"] = this.hasPhoto;
        return data; 
    }
}

export interface IObservationSyncCommandObservationItem {
    /** GUID of the observation */
    id: string;
    /** Longitude where observation is registered */
    longitude?: number;
    /** Latitude where observation is registered */
    latitude?: number;
    /** Type of observation (schade, other) */
    type?: number;
    /** Remarks entered by the trapper */
    remarks?: string | undefined;
    /** Creation date of the observation */
    recordedOn?: Date;
    /** Indicator whether a photo has been made */
    hasPhoto?: boolean;
}

export class GetGeoServerSettingsResponse implements IGetGeoServerSettingsResponse {
    url?: string;
    accessKey?: string;
    backOfficeUser?: string;
    mobileUser?: string;

    constructor(data?: IGetGeoServerSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.accessKey = _data["accessKey"];
            this.backOfficeUser = _data["backOfficeUser"];
            this.mobileUser = _data["mobileUser"];
        }
    }

    static fromJS(data: any): GetGeoServerSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeoServerSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["accessKey"] = this.accessKey;
        data["backOfficeUser"] = this.backOfficeUser;
        data["mobileUser"] = this.mobileUser;
        return data; 
    }
}

export interface IGetGeoServerSettingsResponse {
    url?: string;
    accessKey?: string;
    backOfficeUser?: string;
    mobileUser?: string;
}

export class GetObservationDetailsResponseItem implements IGetObservationDetailsResponseItem {
    /** GUID of the observation */
    id?: string;
    /** GUID of the user who created observation */
    createdBy?: string;
    /** Type of observation (schade, other) */
    type?: number;
    /** URL on blob storage where image is stored */
    photoUrl?: string;
    /** Remarks placed by trapper */
    remarks?: string;
    /** Created on */
    createdOn?: Date;
    /** Positon defined by names of Sub Area Hour Square, Rayon and Hour Square */
    position?: string;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Recorded on */
    recordedOn?: Date;
    /** Longitude of observation where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;

    constructor(data?: IGetObservationDetailsResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.type = _data["type"];
            this.photoUrl = _data["photoUrl"];
            this.remarks = _data["remarks"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.position = _data["position"];
            this.archived = _data["archived"];
            this.recordedOn = _data["recordedOn"] ? new Date(_data["recordedOn"].toString()) : <any>undefined;
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): GetObservationDetailsResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetObservationDetailsResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["type"] = this.type;
        data["photoUrl"] = this.photoUrl;
        data["remarks"] = this.remarks;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["archived"] = this.archived;
        data["recordedOn"] = this.recordedOn ? this.recordedOn.toISOString() : <any>undefined;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data; 
    }
}

export interface IGetObservationDetailsResponseItem {
    /** GUID of the observation */
    id?: string;
    /** GUID of the user who created observation */
    createdBy?: string;
    /** Type of observation (schade, other) */
    type?: number;
    /** URL on blob storage where image is stored */
    photoUrl?: string;
    /** Remarks placed by trapper */
    remarks?: string;
    /** Created on */
    createdOn?: Date;
    /** Positon defined by names of Sub Area Hour Square, Rayon and Hour Square */
    position?: string;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Recorded on */
    recordedOn?: Date;
    /** Longitude of observation where it is registered */
    longitude?: number;
    /** Latitude of trap where it is registered */
    latitude?: number;
}

export class PagedResponseOfGetObservationDetailsResponseItem implements IPagedResponseOfGetObservationDetailsResponseItem {
    items?: GetObservationDetailsResponseItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;

    constructor(data?: IPagedResponseOfGetObservationDetailsResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetObservationDetailsResponseItem.fromJS(item));
            }
            this.itemsTotalCount = _data["itemsTotalCount"];
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResponseOfGetObservationDetailsResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfGetObservationDetailsResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemsTotalCount"] = this.itemsTotalCount;
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPagedResponseOfGetObservationDetailsResponseItem {
    items?: GetObservationDetailsResponseItem[];
    itemsTotalCount?: number;
    currentPage?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
}

export class ObservationUpdateCommand implements IObservationUpdateCommand {
    /** GUID of the observation */
    id!: string;
    /** Observation type (schade, overig) */
    type?: ObservationType;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Remarks for this observation */
    remarks?: string | undefined;

    constructor(data?: IObservationUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.archived = _data["archived"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): ObservationUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["archived"] = this.archived;
        data["remarks"] = this.remarks;
        return data; 
    }
}

export interface IObservationUpdateCommand {
    /** GUID of the observation */
    id: string;
    /** Observation type (schade, overig) */
    type?: ObservationType;
    /** Indicator whether observation is archived */
    archived?: boolean;
    /** Remarks for this observation */
    remarks?: string | undefined;
}

export enum ObservationType {
    Schade = 1,
    Overig = 2,
}

export class ListResponseOfGetOverlayLayersResponseItem implements IListResponseOfGetOverlayLayersResponseItem {
    items?: GetOverlayLayersResponseItem[];

    constructor(data?: IListResponseOfGetOverlayLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOverlayLayersResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetOverlayLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetOverlayLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetOverlayLayersResponseItem {
    items?: GetOverlayLayersResponseItem[];
}

export class GetOverlayLayersResponseItem implements IGetOverlayLayersResponseItem {
    /** Technical name of layer */
    name?: string;
    /** Full name */
    fullName?: string;
    /** Name on screen for this layer */
    displayName?: string;
    /** Category code */
    categoryCode?: OverlayLayerCategoryCode;
    /** Category name */
    categoryDisplayName?: string;
    /** Url where layer can be retrieved from */
    url?: string;
    /** Indicator for layers stacking on eachother */
    displayZIndex?: number;
    /** Color to be used for drawing layer */
    color?: string;
    /** Geometry name */
    geometryFieldName?: string;
    /** Strategy for showing layers on screen */
    lookupStrategy?: OverlayLayerLookupStrategy;
    /** Lookup codes to be used for different maps */
    defaultMapStyle?: MapStyleLookupKeyCode;
    /** How long items should be cached */
    cacheSettings?: OverlayLayerCacheSettings;
    /** Width on screen for this layer */
    width?: number;
    /** Indicator whether it is used on backoffice, mobile or both */
    platformType?: OverlayLayerPlatformType;
    /** Overlay type (wms, wfs, wmts) */
    type?: OverlayLayerType;

    constructor(data?: IGetOverlayLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fullName = _data["fullName"];
            this.displayName = _data["displayName"];
            this.categoryCode = _data["categoryCode"];
            this.categoryDisplayName = _data["categoryDisplayName"];
            this.url = _data["url"];
            this.displayZIndex = _data["displayZIndex"];
            this.color = _data["color"];
            this.geometryFieldName = _data["geometryFieldName"];
            this.lookupStrategy = _data["lookupStrategy"];
            this.defaultMapStyle = _data["defaultMapStyle"] ? MapStyleLookupKeyCode.fromJS(_data["defaultMapStyle"]) : <any>undefined;
            this.cacheSettings = _data["cacheSettings"] ? OverlayLayerCacheSettings.fromJS(_data["cacheSettings"]) : <any>undefined;
            this.width = _data["width"];
            this.platformType = _data["platformType"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GetOverlayLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetOverlayLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["displayName"] = this.displayName;
        data["categoryCode"] = this.categoryCode;
        data["categoryDisplayName"] = this.categoryDisplayName;
        data["url"] = this.url;
        data["displayZIndex"] = this.displayZIndex;
        data["color"] = this.color;
        data["geometryFieldName"] = this.geometryFieldName;
        data["lookupStrategy"] = this.lookupStrategy;
        data["defaultMapStyle"] = this.defaultMapStyle ? this.defaultMapStyle.toJSON() : <any>undefined;
        data["cacheSettings"] = this.cacheSettings ? this.cacheSettings.toJSON() : <any>undefined;
        data["width"] = this.width;
        data["platformType"] = this.platformType;
        data["type"] = this.type;
        return data; 
    }
}

export interface IGetOverlayLayersResponseItem {
    /** Technical name of layer */
    name?: string;
    /** Full name */
    fullName?: string;
    /** Name on screen for this layer */
    displayName?: string;
    /** Category code */
    categoryCode?: OverlayLayerCategoryCode;
    /** Category name */
    categoryDisplayName?: string;
    /** Url where layer can be retrieved from */
    url?: string;
    /** Indicator for layers stacking on eachother */
    displayZIndex?: number;
    /** Color to be used for drawing layer */
    color?: string;
    /** Geometry name */
    geometryFieldName?: string;
    /** Strategy for showing layers on screen */
    lookupStrategy?: OverlayLayerLookupStrategy;
    /** Lookup codes to be used for different maps */
    defaultMapStyle?: MapStyleLookupKeyCode;
    /** How long items should be cached */
    cacheSettings?: OverlayLayerCacheSettings;
    /** Width on screen for this layer */
    width?: number;
    /** Indicator whether it is used on backoffice, mobile or both */
    platformType?: OverlayLayerPlatformType;
    /** Overlay type (wms, wfs, wmts) */
    type?: OverlayLayerType;
}

export enum OverlayLayerCategoryCode {
    MapAreas = 0,
    MapLocations = 1,
    ReportTracking = 2,
    ReportGeoRegionCatches = 3,
    HeatMapOfCatches = 4,
    DefaultLayers = 5,
}

export enum OverlayLayerLookupStrategy {
    All = 0,
    BBox = 1,
    Tracking = 2,
}

export class MapStyleLookupKeyCode implements IMapStyleLookupKeyCode {
    code?: string;

    constructor(data?: IMapStyleLookupKeyCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): MapStyleLookupKeyCode {
        data = typeof data === 'object' ? data : {};
        let result = new MapStyleLookupKeyCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IMapStyleLookupKeyCode {
    code?: string;
}

export class OverlayLayerCacheSettings implements IOverlayLayerCacheSettings {
    cacheStrategy?: OverlayLayerCacheStrategy;
    durationSeconds?: number;

    constructor(data?: IOverlayLayerCacheSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cacheStrategy = _data["cacheStrategy"];
            this.durationSeconds = _data["durationSeconds"];
        }
    }

    static fromJS(data: any): OverlayLayerCacheSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OverlayLayerCacheSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheStrategy"] = this.cacheStrategy;
        data["durationSeconds"] = this.durationSeconds;
        return data; 
    }
}

export interface IOverlayLayerCacheSettings {
    cacheStrategy?: OverlayLayerCacheStrategy;
    durationSeconds?: number;
}

export enum OverlayLayerCacheStrategy {
    NoCache = 0,
    CacheFirst = 1,
    NetworkFirst = 2,
}

export enum OverlayLayerPlatformType {
    All = 0,
    BackofficeOnly = 1,
    MobileOnly = 2,
}

export enum OverlayLayerType {
    Wms = 1,
    Wfs = 2,
    Wmts = 3,
}

export class ListResponseOfGetBackgroundLayersResponseItem implements IListResponseOfGetBackgroundLayersResponseItem {
    items?: GetBackgroundLayersResponseItem[];

    constructor(data?: IListResponseOfGetBackgroundLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBackgroundLayersResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetBackgroundLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetBackgroundLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetBackgroundLayersResponseItem {
    items?: GetBackgroundLayersResponseItem[];
}

export class GetBackgroundLayersResponseItem implements IGetBackgroundLayersResponseItem {
    /** Id of the layer */
    id?: string;
    /** Name of the layer */
    name?: string;
    /** URL where background layer is retrieved from */
    url?: string;
    /** Service type (wmts, mvt) */
    serviceType?: MapServiceType;
    /** Network type online of offline */
    networkType?: MapNetworkType;
    /** Overlay type (wms, wfs, wmts) */
    defaultOverlayLayer?: string | undefined;

    constructor(data?: IGetBackgroundLayersResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.serviceType = _data["serviceType"];
            this.networkType = _data["networkType"];
            this.defaultOverlayLayer = _data["defaultOverlayLayer"];
        }
    }

    static fromJS(data: any): GetBackgroundLayersResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetBackgroundLayersResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        data["serviceType"] = this.serviceType;
        data["networkType"] = this.networkType;
        data["defaultOverlayLayer"] = this.defaultOverlayLayer;
        return data; 
    }
}

export interface IGetBackgroundLayersResponseItem {
    /** Id of the layer */
    id?: string;
    /** Name of the layer */
    name?: string;
    /** URL where background layer is retrieved from */
    url?: string;
    /** Service type (wmts, mvt) */
    serviceType?: MapServiceType;
    /** Network type online of offline */
    networkType?: MapNetworkType;
    /** Overlay type (wms, wfs, wmts) */
    defaultOverlayLayer?: string | undefined;
}

export enum MapServiceType {
    Wmts = 1,
    Mvt = 2,
}

export enum MapNetworkType {
    Online = 1,
    Offline = 2,
}

export class GetBackgroundLayersQuery implements IGetBackgroundLayersQuery {

    constructor(data?: IGetBackgroundLayersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetBackgroundLayersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetBackgroundLayersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetBackgroundLayersQuery {
}

export class GetMapStylesResponse implements IGetMapStylesResponse {
    items?: MapStyleLookup[];

    constructor(data?: IGetMapStylesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MapStyleLookup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMapStylesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMapStylesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMapStylesResponse {
    items?: MapStyleLookup[];
}

export class MapStyleLookup implements IMapStyleLookup {
    /** key identifier */
    key?: MapStyleLookupKey;
    /** Icon that should be used for this style */
    iconName?: string;

    constructor(data?: IMapStyleLookup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] ? MapStyleLookupKey.fromJS(_data["key"]) : <any>undefined;
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): MapStyleLookup {
        data = typeof data === 'object' ? data : {};
        let result = new MapStyleLookup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["iconName"] = this.iconName;
        return data; 
    }
}

export interface IMapStyleLookup {
    /** key identifier */
    key?: MapStyleLookupKey;
    /** Icon that should be used for this style */
    iconName?: string;
}

export class MapStyleLookupKey implements IMapStyleLookupKey {
    lookupKeyCode?: MapStyleLookupKeyCode;
    trapTypeId?: string | undefined;
    trapStatus?: TrapStatus | undefined;

    constructor(data?: IMapStyleLookupKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupKeyCode = _data["lookupKeyCode"] ? MapStyleLookupKeyCode.fromJS(_data["lookupKeyCode"]) : <any>undefined;
            this.trapTypeId = _data["trapTypeId"];
            this.trapStatus = _data["trapStatus"];
        }
    }

    static fromJS(data: any): MapStyleLookupKey {
        data = typeof data === 'object' ? data : {};
        let result = new MapStyleLookupKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupKeyCode"] = this.lookupKeyCode ? this.lookupKeyCode.toJSON() : <any>undefined;
        data["trapTypeId"] = this.trapTypeId;
        data["trapStatus"] = this.trapStatus;
        return data; 
    }
}

export interface IMapStyleLookupKey {
    lookupKeyCode?: MapStyleLookupKeyCode;
    trapTypeId?: string | undefined;
    trapStatus?: TrapStatus | undefined;
}

export class ListResponseOfGetTrapTypesResponseItem implements IListResponseOfGetTrapTypesResponseItem {
    items?: GetTrapTypesResponseItem[];

    constructor(data?: IListResponseOfGetTrapTypesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrapTypesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetTrapTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetTrapTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetTrapTypesResponseItem {
    items?: GetTrapTypesResponseItem[];
}

export class GetTrapTypesResponseItem extends NamedEntityItem implements IGetTrapTypesResponseItem {
    trappingTypeId?: string;
    allowedStatuses?: TrapStatus[];

    constructor(data?: IGetTrapTypesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.trappingTypeId = _data["trappingTypeId"];
            if (Array.isArray(_data["allowedStatuses"])) {
                this.allowedStatuses = [] as any;
                for (let item of _data["allowedStatuses"])
                    this.allowedStatuses!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTrapTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trappingTypeId"] = this.trappingTypeId;
        if (Array.isArray(this.allowedStatuses)) {
            data["allowedStatuses"] = [];
            for (let item of this.allowedStatuses)
                data["allowedStatuses"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IGetTrapTypesResponseItem extends INamedEntityItem {
    trappingTypeId?: string;
    allowedStatuses?: TrapStatus[];
}

export class GetTrapTypesQuery implements IGetTrapTypesQuery {

    constructor(data?: IGetTrapTypesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetTrapTypesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrapTypesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetTrapTypesQuery {
}

export class ListResponseOfGetCatchTypesResponseItem implements IListResponseOfGetCatchTypesResponseItem {
    items?: GetCatchTypesResponseItem[];

    constructor(data?: IListResponseOfGetCatchTypesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCatchTypesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetCatchTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetCatchTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetCatchTypesResponseItem {
    items?: GetCatchTypesResponseItem[];
}

export class GetCatchTypesResponseItem extends NamedEntityItem implements IGetCatchTypesResponseItem {
    /** Is this catch type used for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order to be used in listing on mobile */
    order?: number;

    constructor(data?: IGetCatchTypesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isByCatch = _data["isByCatch"];
            this.animalType = _data["animalType"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): GetCatchTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isByCatch"] = this.isByCatch;
        data["animalType"] = this.animalType;
        data["order"] = this.order;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetCatchTypesResponseItem extends INamedEntityItem {
    /** Is this catch type used for catch or by-catch */
    isByCatch?: boolean;
    /** Animal type (Mammal, Bird, Fish or Other) */
    animalType?: AnimalType;
    /** Order to be used in listing on mobile */
    order?: number;
}

export enum AnimalType {
    Mammal = 1,
    Bird = 2,
    Fish = 3,
    Other = 4,
}

export class GetCatchTypesQuery implements IGetCatchTypesQuery {

    constructor(data?: IGetCatchTypesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetCatchTypesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCatchTypesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetCatchTypesQuery {
}

export class ListResponseOfGetTrappingTypesResponseItem implements IListResponseOfGetTrappingTypesResponseItem {
    items?: GetTrappingTypesResponseItem[];

    constructor(data?: IListResponseOfGetTrappingTypesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTrappingTypesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetTrappingTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetTrappingTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetTrappingTypesResponseItem {
    items?: GetTrappingTypesResponseItem[];
}

export class GetTrappingTypesResponseItem extends NamedEntityItem implements IGetTrappingTypesResponseItem {

    constructor(data?: IGetTrappingTypesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): GetTrappingTypesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTrappingTypesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetTrappingTypesResponseItem extends INamedEntityItem {
}

export class ListResponseOfGetTimeRegistrationCategoriesResponseItem implements IListResponseOfGetTimeRegistrationCategoriesResponseItem {
    items?: GetTimeRegistrationCategoriesResponseItem[];

    constructor(data?: IListResponseOfGetTimeRegistrationCategoriesResponseItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTimeRegistrationCategoriesResponseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResponseOfGetTimeRegistrationCategoriesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponseOfGetTimeRegistrationCategoriesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResponseOfGetTimeRegistrationCategoriesResponseItem {
    items?: GetTimeRegistrationCategoriesResponseItem[];
}

export class GetTimeRegistrationCategoriesResponseItem extends NamedEntityItem implements IGetTimeRegistrationCategoriesResponseItem {
    active?: boolean;

    constructor(data?: IGetTimeRegistrationCategoriesResponseItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): GetTimeRegistrationCategoriesResponseItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetTimeRegistrationCategoriesResponseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetTimeRegistrationCategoriesResponseItem extends INamedEntityItem {
    active?: boolean;
}

export class GetBlobStorageSasKeyResponse implements IGetBlobStorageSasKeyResponse {
    sasKey?: string;

    constructor(data?: IGetBlobStorageSasKeyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sasKey = _data["sasKey"];
        }
    }

    static fromJS(data: any): GetBlobStorageSasKeyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetBlobStorageSasKeyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sasKey"] = this.sasKey;
        return data; 
    }
}

export interface IGetBlobStorageSasKeyResponse {
    sasKey?: string;
}

export class GetLocationAreaDetailsResponse implements IGetLocationAreaDetailsResponse {
    subAreaHourSquareId?: string;
    hourSquare?: NamedEntityItem;
    subArea?: NamedEntityItem;
    catchArea?: NamedEntityItem;
    rayon?: NamedEntityItem;
    organization?: NamedEntityItem;

    constructor(data?: IGetLocationAreaDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subAreaHourSquareId = _data["subAreaHourSquareId"];
            this.hourSquare = _data["hourSquare"] ? NamedEntityItem.fromJS(_data["hourSquare"]) : <any>undefined;
            this.subArea = _data["subArea"] ? NamedEntityItem.fromJS(_data["subArea"]) : <any>undefined;
            this.catchArea = _data["catchArea"] ? NamedEntityItem.fromJS(_data["catchArea"]) : <any>undefined;
            this.rayon = _data["rayon"] ? NamedEntityItem.fromJS(_data["rayon"]) : <any>undefined;
            this.organization = _data["organization"] ? NamedEntityItem.fromJS(_data["organization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLocationAreaDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationAreaDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subAreaHourSquareId"] = this.subAreaHourSquareId;
        data["hourSquare"] = this.hourSquare ? this.hourSquare.toJSON() : <any>undefined;
        data["subArea"] = this.subArea ? this.subArea.toJSON() : <any>undefined;
        data["catchArea"] = this.catchArea ? this.catchArea.toJSON() : <any>undefined;
        data["rayon"] = this.rayon ? this.rayon.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLocationAreaDetailsResponse {
    subAreaHourSquareId?: string;
    hourSquare?: NamedEntityItem;
    subArea?: NamedEntityItem;
    catchArea?: NamedEntityItem;
    rayon?: NamedEntityItem;
    organization?: NamedEntityItem;
}

export class GetLocationAreaDataResponse implements IGetLocationAreaDataResponse {
    catchArea?: GetLocationAreaDataResponseArea;
    subArea?: GetLocationAreaDataResponseArea;

    constructor(data?: IGetLocationAreaDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catchArea = _data["catchArea"] ? GetLocationAreaDataResponseArea.fromJS(_data["catchArea"]) : <any>undefined;
            this.subArea = _data["subArea"] ? GetLocationAreaDataResponseArea.fromJS(_data["subArea"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLocationAreaDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationAreaDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catchArea"] = this.catchArea ? this.catchArea.toJSON() : <any>undefined;
        data["subArea"] = this.subArea ? this.subArea.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLocationAreaDataResponse {
    catchArea?: GetLocationAreaDataResponseArea;
    subArea?: GetLocationAreaDataResponseArea;
}

export class GetLocationAreaDataResponseArea implements IGetLocationAreaDataResponseArea {
    lastWeekTimeTotal?: GetLocationAreaDataResponseAreaTimeSummary;
    catchingTrapsTotal?: number;
    catchingTraps?: GetLocationAreaDataResponseAreaTrapSummary[];
    lastWeekCatchesTotal?: number;
    lastWeekCatches?: GetLocationAreaDataResponseAreaTrapSummary[];
    lastWeekByCatchesTotal?: number;
    lastWeekByCatches?: GetLocationAreaDataResponseAreaTrapSummary[];

    constructor(data?: IGetLocationAreaDataResponseArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastWeekTimeTotal = _data["lastWeekTimeTotal"] ? GetLocationAreaDataResponseAreaTimeSummary.fromJS(_data["lastWeekTimeTotal"]) : <any>undefined;
            this.catchingTrapsTotal = _data["catchingTrapsTotal"];
            if (Array.isArray(_data["catchingTraps"])) {
                this.catchingTraps = [] as any;
                for (let item of _data["catchingTraps"])
                    this.catchingTraps!.push(GetLocationAreaDataResponseAreaTrapSummary.fromJS(item));
            }
            this.lastWeekCatchesTotal = _data["lastWeekCatchesTotal"];
            if (Array.isArray(_data["lastWeekCatches"])) {
                this.lastWeekCatches = [] as any;
                for (let item of _data["lastWeekCatches"])
                    this.lastWeekCatches!.push(GetLocationAreaDataResponseAreaTrapSummary.fromJS(item));
            }
            this.lastWeekByCatchesTotal = _data["lastWeekByCatchesTotal"];
            if (Array.isArray(_data["lastWeekByCatches"])) {
                this.lastWeekByCatches = [] as any;
                for (let item of _data["lastWeekByCatches"])
                    this.lastWeekByCatches!.push(GetLocationAreaDataResponseAreaTrapSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLocationAreaDataResponseArea {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationAreaDataResponseArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastWeekTimeTotal"] = this.lastWeekTimeTotal ? this.lastWeekTimeTotal.toJSON() : <any>undefined;
        data["catchingTrapsTotal"] = this.catchingTrapsTotal;
        if (Array.isArray(this.catchingTraps)) {
            data["catchingTraps"] = [];
            for (let item of this.catchingTraps)
                data["catchingTraps"].push(item.toJSON());
        }
        data["lastWeekCatchesTotal"] = this.lastWeekCatchesTotal;
        if (Array.isArray(this.lastWeekCatches)) {
            data["lastWeekCatches"] = [];
            for (let item of this.lastWeekCatches)
                data["lastWeekCatches"].push(item.toJSON());
        }
        data["lastWeekByCatchesTotal"] = this.lastWeekByCatchesTotal;
        if (Array.isArray(this.lastWeekByCatches)) {
            data["lastWeekByCatches"] = [];
            for (let item of this.lastWeekByCatches)
                data["lastWeekByCatches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLocationAreaDataResponseArea {
    lastWeekTimeTotal?: GetLocationAreaDataResponseAreaTimeSummary;
    catchingTrapsTotal?: number;
    catchingTraps?: GetLocationAreaDataResponseAreaTrapSummary[];
    lastWeekCatchesTotal?: number;
    lastWeekCatches?: GetLocationAreaDataResponseAreaTrapSummary[];
    lastWeekByCatchesTotal?: number;
    lastWeekByCatches?: GetLocationAreaDataResponseAreaTrapSummary[];
}

export class GetLocationAreaDataResponseAreaTimeSummary implements IGetLocationAreaDataResponseAreaTimeSummary {
    hours?: number;
    minutes?: number;

    constructor(data?: IGetLocationAreaDataResponseAreaTimeSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hours = _data["hours"];
            this.minutes = _data["minutes"];
        }
    }

    static fromJS(data: any): GetLocationAreaDataResponseAreaTimeSummary {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationAreaDataResponseAreaTimeSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hours"] = this.hours;
        data["minutes"] = this.minutes;
        return data; 
    }
}

export interface IGetLocationAreaDataResponseAreaTimeSummary {
    hours?: number;
    minutes?: number;
}

export class GetLocationAreaDataResponseAreaTrapSummary implements IGetLocationAreaDataResponseAreaTrapSummary {
    number?: number;
    type?: string | undefined;

    constructor(data?: IGetLocationAreaDataResponseAreaTrapSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GetLocationAreaDataResponseAreaTrapSummary {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationAreaDataResponseAreaTrapSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["type"] = this.type;
        return data; 
    }
}

export interface IGetLocationAreaDataResponseAreaTrapSummary {
    number?: number;
    type?: string | undefined;
}

export class GetAreaEntitiesResponse implements IGetAreaEntitiesResponse {
    items?: NamedEntityItem[];

    constructor(data?: IGetAreaEntitiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NamedEntityItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAreaEntitiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAreaEntitiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAreaEntitiesResponse {
    items?: NamedEntityItem[];
}

export class GetCurrentUserProfileResponse implements IGetCurrentUserProfileResponse {
    /** GUID of the user */
    id?: string;
    /** Full name from the user
             */
    name?: string;
    /** Email that serves as UPN (User Prinicapal Name) for Azure AD account */
    email?: string;
    /** Indication whether user is granted access (true or false) */
    authorized?: boolean;
    /** Indication if the user complied with the regulations policies for using trAPP */
    confidentialityConfirmed?: boolean;
    /** Organization to which user belongs */
    organizationId?: string | undefined;

    constructor(data?: IGetCurrentUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.authorized = _data["authorized"];
            this.confidentialityConfirmed = _data["confidentialityConfirmed"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): GetCurrentUserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentUserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["authorized"] = this.authorized;
        data["confidentialityConfirmed"] = this.confidentialityConfirmed;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface IGetCurrentUserProfileResponse {
    /** GUID of the user */
    id?: string;
    /** Full name from the user
             */
    name?: string;
    /** Email that serves as UPN (User Prinicapal Name) for Azure AD account */
    email?: string;
    /** Indication whether user is granted access (true or false) */
    authorized?: boolean;
    /** Indication if the user complied with the regulations policies for using trAPP */
    confidentialityConfirmed?: boolean;
    /** Organization to which user belongs */
    organizationId?: string | undefined;
}

export class UserSessionCreateResult implements IUserSessionCreateResult {
    sessionId?: string;

    constructor(data?: IUserSessionCreateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): UserSessionCreateResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSessionCreateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        return data; 
    }
}

export interface IUserSessionCreateResult {
    sessionId?: string;
}

export class SessionAccessTokenCreateResult implements ISessionAccessTokenCreateResult {
    sessionAccessTokenId?: string;

    constructor(data?: ISessionAccessTokenCreateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionAccessTokenId = _data["sessionAccessTokenId"];
        }
    }

    static fromJS(data: any): SessionAccessTokenCreateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SessionAccessTokenCreateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionAccessTokenId"] = this.sessionAccessTokenId;
        return data; 
    }
}

export interface ISessionAccessTokenCreateResult {
    sessionAccessTokenId?: string;
}

export class SessionAccessTokenCreateCommand implements ISessionAccessTokenCreateCommand {
    accessToken!: string;

    constructor(data?: ISessionAccessTokenCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): SessionAccessTokenCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SessionAccessTokenCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface ISessionAccessTokenCreateCommand {
    accessToken: string;
}

export class UserSessionTerminateResult implements IUserSessionTerminateResult {
    userEmail?: string;

    constructor(data?: IUserSessionTerminateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): UserSessionTerminateResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSessionTerminateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail;
        return data; 
    }
}

export interface IUserSessionTerminateResult {
    userEmail?: string;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}